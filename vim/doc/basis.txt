*basis.txt*    For Vim version 7.4 or later.

        basis lib for jmend's vimrc~

Basis                                                            *bss* *basis*

1. Description                                  |basis-desc|
   1.1 Requirements                             |basis-reqs|
2. Functions                                    |basis-misc|
3. Types                                        |basis-types|
   3.1 Type Definitions                         |basis-typedef|
   3.2 Type{}                                   |basis-type|
   3.3 Cursor{}                                 |basis-cursor|
   3.4 View{}                                   |basis-view|

==============================================================================
1. Description                                                    *basis-desc*

Basis is my "standard-library" of sorts. Mostly a collection of fun vimscript.

Uses RFC 2119 key words: "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL".

1.1 Requirements                                                  *basis-reqs*
----------------

A Vim version 8.0 or later is REQUIRED. The option 'compatible' MUST NOT be
set.

==============================================================================
2. Functions                                                      *basis-misc*

USAGE                            RESULT         DESCRIPTION

bss#cursor#Save()                |Cursor{}|       Save the cursor
bss#type#Type()                  |Type()|         Get type checking function
bss#type#Typed()                 T              Check obj against type desc
bss#view#View()                  |View{}|         Create a new view
bss#view#TermView()              |View{}|         Create a view for `:term`
bss#view#ScratchView()           |View{}|         Create a scratch buffer view

DEFINITIONS

==============================================================================
3. Types                                                         *basis-types*

3.1 Type Defintions                                            *basis-typedef*
-------------------

You can't define new types in vimscript, so for this section a type refers to
a |dict| with a specified set of fields and methods. The name of a type will
be suffixed by curly-braces, eg. |Cursor{}|.

In general fields will use lower snake-case, while methods will be upper camel
case.

To support this |basis-type| defines a set of helper functions which accept
|bss-descriptors| and define checkers which assert that a passed value matches
the declared description.


3.2 Type                                                          *basis-type*
--------

The core idea behind the type system defined by |bss#type#Type()| is:

    1. User provides a declarative descriptor of the type.
>
        let s:Cursor = bss#type#Type({'Restore': v:t_func})
<
    2. Define a checker function
>
        let l:value = s:Cursor({'Restore': function('s:Restore')})
<
    3. Assert where necessary
        - Users SHOULD check at API boundaries
        - Users MAY check internally

All of this functionality is disabled by default, and must be enabled using
|bss#type#Enable()| (Likewise use |bss#type#Disable()| to disable it).

FUNCTIONS

bss#type#Type({desc}) -> |Type()|                              *bss#type#Type()*

    Defines a "Checker" |Funcref| that ensures values passed to it match the
    |bss-type-descriptor| {desc}. The returned |Funcref| accepts a single
    argument, and will throw a 'ERROR(Type)'-prefixed exception if the value
    isn't matched (assuming type checking is enabled).

bss#type#Typed({desc}, {value}) -> type({value})            *bss#type#Typed()*

    Runs the checker defined by {desc} (see |bss#type#Type()|) against the
    {value}, returning the {value} if it matches, otherwise throwing
    'ERROR(Type)'.


3.2.1 Type Descriptors                                   *bss-type-descriptor*
----------------------

A type descriptor is a declarative way to define a type. An instance of the
type simply means a value which matches the descriptor's "shape". What the
descriptor means depends on the type of the descriptor value:

DESCRIPTOR

|Number| / |v:t_TYPE|   When a |Number| is encountered, it is interpreted as a
                    vim type (see |v:t_TYPE| and |type()|) and the
                    corresponding checker will assert that checked value:
                        1. Has |type()| that matches the descriptor's
                           |Number|.

|String|              Defines a checker which asserts the checked value:
                        1. Has |type()| of |v:t_string|.
                        2. Equals the descritor |String| literally and with
                           case sensitivity.

|Dictionary|          Defines a checker which asserts the checked value:
                        1. Has |type()| of |v:t_dict|.
                        2. Has |keys()| which are a super-set of the
                           descriptor's |keys()|.
                        3. Every matching key must match the value of the
                           corresponding key in the descriptor.

|List|                Defines a checker which asserts the checked value:
                        1. Has |type()| of |v:t_list|.
                        2. Has values which all match any of the descriptor's
                           entries. So an empty list applies no constraints,
                           allowing any values.

Checker |Func|        Defines a checker which asserts the checked value:
                        1. Matches the supplied checker's original descriptor.
                    The user MUST NOT alter the |Funcref| returned by
                    |bss#type#Type()| in order to use it in another
                    descriptor.

Non-Checker |Func|    Defines a checker which asserts the checked value:
                        1. Has |type()| of |v:t_func|.

3.3 Cursor{}                                           *basis-cursor* *Cursor{}*
------------

This represents a saved location of a cursor. To create an instance, use the
|bss#cursor#Save()| function.

>
    let l:cursor = bss#cursor#Save()
    call win_gotoid(...)
    ...
    call l:cursor.Restore()
<

CONSTRUCTORS

bss#cursor#Save() -> |Cursor{}|                              *bss#cursor#Save()*

    Saves the current cursor location (window, line and column) and returns a
    |Cursor{}| which can be used to restore the cursor to this location.

FIELDS

    None

METHODS

Cursor.Restore() -> nothing                                 *Cursor.Restore()*

    Restore the location of the cursor to the location where it was saved.

3.4 View{}                                               *basis-view* *View{}*
----------

This represents a reusable buffer and window combination. If the view is still
valid (according to |View.IsValid()|), calling |View.GoToWindow()| will put
the cursor back in the window. If the view has become invalid, then a new
buffer/window will be created, and the cursor will be left in the new window.

OVERVIEW

bss#view#View()		Create a new view
bss#view#TermView()	Create a new term view

View.bufnr		The view's buffer number
View.winid		The view's window id
View.options		The local options to apply on the view

View.Run({cmd})		Run a `:term` using the view as the output
View.Exec({cmd})	Execute (`:execute`) the command in the view window
View.AddOption({opt})	Add {opt} to the |View.options| list
View.ApplyOptions()	Apply the |View.options| entries

CONSTRUCTORS

bss#view#View([{fields}]) -> |View{}|                          *bss#view#View()*

    Creates an unopened |View{}|. If the optional |dict| {fields} argument is
    present, then the view instance is extended (|extend()|) with the {fields}
    argument.
>
        " Create a new view
        let l:view = bss#view#View()

        " Create a new view, specifying the buffer to use
        let l:view = bss#view#View({'bufnr': 32})

        " Create a new view, with options to set locally
        let l:view = bss#view#View({'options': ['nobuflisted']})
<

bss#view#TermView() -> |View{}|                            *bss#view#TermView()*

    Creates a |View{}| meant for holding output from a `:term` execution.

FIELDS

bufnr                                                             *View.bufnr*

    The buffer number (see |bufnr()|) of the view, or |v:none| if unset.

winid                                                             *View.winid*

    The window id (see |win_getid()|) of the view, or |v:none| if unset.

options                                                         *View.options*

    A |list| of |string| which specifies options. Each entry of this list will
    be applied by |View.ApplyOptions()| using `:setlocal`.

METHODS

View.Exec({cmd}) -> |View{}|                                       *View.Exec()*

    `:execute` the specified EX command in the |View{}|'s window. {cmd} must
    be a |string|.

View.Run({cmd}) -> |View{}|                                         *View.Run()*

    Run `:term {cmd}` within the |View{}|.

View.AddOption({opt}) -> |View{}|                             *View.AddOption()*

    Add an option to the |View.options| list.

View.ApplyOptions() -> nothing                           *View.ApplyOptions()*

    For each entry in |View.options|, apply it using `:setlocal` on the
    current window.

vim:tw=78:ts=8:sw=4:ft=help:norl:cocu=nic:
