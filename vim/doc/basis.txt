*basis.txt*    For Vim version 7.4 or later.

        basis lib for jmend's vimrc~

Basis                                                            *bss* *basis*

1. Description                                  |basis-desc|
   1.1 Requirements                             |basis-reqs|
2. Misc. Functions                              |basis-misc|

==============================================================================
I. Description                                                    *basis-desc*

Basis is my "standard-library" of sorts. Mostly a collection of fun vimscript.

1.1 Requirements                                                  *basis-reqs*
----------------

This plugin works with Vim version 7.4. It only works if the 'compatible'
setting is not set.

==============================================================================
2. Misc. Functions                                                *basis-misc*

USAGE                            RESULT         DESCRIPTION

bss#cursor#Save()                |Cursor{}|       Save the cursor
bss#view#View()                  |View{}|         Create a new view
bss#view#TermView()              |View{}|         Create a view for `:term`

DEFINITIONS

==============================================================================
3. Types                                                         *basis-types*

3.0 Type Defintion                                                *basis-type*
------------------

You can't define new types in vimscript, so for this section a type refers to
a |dict| with a specified set of fields and methods. The name of a type will
be suffixed by curly-braces, eg. |Cursor{}|.

In general fields will use lower snake-case, while methods will be upper camel
case.

3.1 Cursor{}                                           *basis-cursor* *Cursor{}*
------------

This represents a saved location of a cursor. To create an instance, use the
|bss#cursor#Save()| function.

>
    let l:cursor = bss#cursor#Save()
    call win_gotoid(...)
    ...
    call l:cursor.Restore()
<

CONSTRUCTORS

bss#cursor#Save() -> |Cursor{}|                            *bss#cursor#Save()*

    Saves the current cursor location (window, line and column) and returns a
    |Cursor{}| which can be used to restore the cursor to this location.

FIELDS

    None

METHODS

Cursor.Restore() -> nothing                                 *Cursor.Restore()*

    Restore the location of the cursor to the location where it was saved.

3.2 View{}                                               *basis-view* *View{}*
----------

This represents a reusable buffer and window combination. If the view is still
valid (according to |View.IsValid()|), calling |View.GoToWindow()| will put
the cursor back in the window. If the view has become invalid, then a new
buffer/window will be created, and the cursor will be left in the new window.

OVERVIEW

bss#view#View()		Create a new view
bss#view#TermView()	Create a new term view

View.bufnr		The view's buffer number
View.winid		The view's window id
View.options		The local options to apply on the view

View.Run({cmd})		Run a `:term` using the view as the output
View.Exec({cmd})	Execute (`:execute`) the command in the view window
View.AddOption({opt})	Add {opt} to the |View.options| list
View.ApplyOptions()	Apply the |View.options| entries

CONSTRUCTORS

bss#view#View([{fields}]) -> |View{}|                        *bss#view#View()*

    Creates an unopened |View{}|. If the optional |dict| {fields} argument is
    present, then the view instance is extended (|extend()|) with the {fields}
    argument.
>
        " Create a new view
        let l:view = bss#view#View()

        " Create a new view, specifying the buffer to use
        let l:view = bss#view#View({'bufnr': 32})

        " Create a new view, with options to set locally
        let l:view = bss#view#View({'options': ['nobuflisted']})
<

bss#view#TermView() -> |View{}|                          *bss#view#TermView()*

    Creates a |View{}| meant for holding output from a `:term` execution.

FIELDS

bufnr                                                             *View.bufnr*

    The buffer number (see |bufnr()|) of the view, or |v:none| if unset.

winid                                                             *View.winid*

    The window id (see |win_getid()|) of the view, or |v:none| if unset.

options                                                         *View.options*

    A |list| of |string| which specifies options. Each entry of this list will
    be applied by |View.ApplyOptions()| using `:setlocal`.

METHODS

View.Exec({cmd}) -> |View{}|                                     *View.Exec()*

    `:execute` the specified EX command in the |View{}|'s window. {cmd} must
    be a |string|.

View.Run({cmd}) -> |View{}|                                       *View.Run()*

    Run `:term {cmd}` within the |View{}|.

View.AddOption({opt}) -> |View{}|                           *View.AddOption()*

    Add an option to the |View.options| list.

View.ApplyOptions() -> nothing                           *View.ApplyOptions()*

    For each entry in |View.options|, apply it using `:setlocal` on the
    current window.

3.3 Alts{}                                               *basis-alts* *Alts{}*
----------

This represents a reusable buffer and window combination. If the view is still
valid (according to |View.IsValid()|), calling |View.GoToWindow()| will put
the cursor back in the window. If the view has become invalid, then a new
buffer/window will be created, and the cursor will be left in the new window.

CONSTRUCTORS

bss#alts#Alts() -> |Alts{}|                                  *bss#alts#Alts()*

    Creates an unopened |View{}|. If the optional |dict| {fields} argument is
    present, then the view instance is extended (|extend()|) with the {fields}
    argument.

FIELDS

alternatives                            *Alts.alternative* *Alts.alternatives*

    A list of |Funcref| which accept a single argument and return a value, or
    |v:none| if the value couldn't be handled.

finalizer                                                     *Alts.finalizer*

    An optional handler |Funcref| (or |v:none|), which will be invoked if any
    of the |Alts.alternatives| produce a value.

METHODS

Alts.Run({value}) -> ?                                            *Alts.Run()*

    Run each entry in |Alts.alternatives| passing {value} as an argument, if
    one succeeds (ie. returns a value other than |v:none|) then return that
    value (or run the |Alts.finalizer| if it's specified).

Alts.Finally({FinallyHandler}) -> ?                           *Alts.Finally()*

    Register the handler to run on the value returned by the
    |Alts.alternative| matched by |Alts.Run()|.

Alts.Add({Handler}) -> |Alts{}|                                   *Alts.Add()*

    Add a |Funcref| {Handler} to the |Alts.alternatives| list. The {Handler}
    should accept a single argument, and either produce a value (if it
    succeeded, or |v:none| if it failed)

Alts.AddPred({Pred}, {Handler}) -> |Alts{}|                   *Alts.AddPred()*

    Registers an |Alts.alternative| which executes {Handler} only if {Pred}
    returns a truthy value.

Alts.AddMatch({pattern}, {Handler}) -> |Alts{}|              *Alts.AddMatch()*

    Registers an |Alts.alternative| which executes {Handler} only if the value
    matches {pattern}.

Alts.AddMagicMatch({pattern}, {Handler}) -> |Alts{}|    *Alts.AddMagicMatch()*

    Like |Alts.AddMatch()| but prepend '\v' to the {pattern} (see |magic|).

Alts.AddDict({mapping}) -> |Alts{}|                           *Alts.AddDict()*

    Add an |Alt.alternative| which matches a value when the {mapping} contains
    a key equivalent to the provided value, it gets mapped to the
    corresponding value in the {mapping}.

vim:tw=78:ts=8:sw=4:ft=help:norl:
