" Copyright (c) 2021 Julian Mendoza
"
" MIT License
"
" Permission is hereby granted, free of charge, to any person obtaining a copy
" of this software and associated documentation files (the "Software"), to deal
" in the Software without restriction, including without limitation the rights
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
" copies of the Software, and to permit persons to whom the Software is
" furnished to do so, subject to the following conditions:
"
" The above copyright notice and this permission notice shall be included in all
" copies or substantial portions of the Software.
"
" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
" SOFTWARE.

""
" jmend's vimrc!
"
" Required Dependency:
"   1. Install vim-plug: https://github.com/junegunn/vim-plug
"   2. Run :PlugInstall
"   3. Restart vim

" Notes {{{
" Misc:
"   :exusage ~ List ex commands
"   :h :t{:r :e} ~ expand() stuff
" Functions:
"   normal: Foo
"   script: <SNR>139_Foo
"   lambda: {'<lambda>42'}
"   numbered: {'42'}
" Motions:
"   inclusive:
"     $ g_ f t e E %
"   exclusive:
"     ...
" Folds:
"   foldlevels:
"     zX -- apply foldlevel
"     zM -- set foldlevel to zero
"     zR -- set foldlevel to deepest level
"     zr -- add one to foldlevel
"     zm -- sub one to foldlevel
"     zx -- apply foldlevel and zv
"   misc:
"     zv -- open folds enough to view cursor
" Tabs:
"   'tabstop':
"     Number of spaces that a <Tab> in a file counts for.
"   'softtabstop':
"     Number of spaces that a <Tab> counts for while performing
"     editing operations, like inserting a <Tab> or using <BS>.
"   'shiftwidth':
"     Number of spaces to use for each step of (auto)indent.
"     Used for 'cindent', <<, >>, etc.
"   'expandtab':
"     Replaces tab characters with spaces.
"   'smarttab':
"     Better tab semantics, especially after new-lines.
" Channel:
"   option:
"     mode:
"       'json' (ch def), 'js', 'nl' (job def), 'raw'
"     callback:
"       { ch, msg -> ... }
"     close_cb:
"       { ch -> ... }
"     drop:
"       'auto': Drop if no callbacks, keep o/w
"       'never': Never drop
" Jobs:
"   option:
"     (in|out|err)_mode: See Channel.option.mode
"     callback: Generic callback
"       { ch, msg -> ... }
"     (out|err)_cb: Specific callbacks
"       { ch, msg -> ... }
"     close_cb:
"       { ch -> ... }
"     exit_cb:
"       { job, status -> ... }
"     drop: See Channel.option.drop
"
" }}} Notes

" Command Prefix:
"   <leader>      : used for global mappings
"   <localleader> : used for buffer-local mappings
let mapleader = '\'
let maplocalleader = '\'

" System Dependencies: {{{
let g:jm_vimrc = {}

" A variety of dependencies on the system
let g:jm_vimrc.deps = #{
      \   jshell: '/usr/bin/jshell',
      \   curl: '/usr/bin/curl',
      \   blaze: '/usr/bin/blaze',
      \   javap: '/usr/bin/javap',
      \   ag: '/usr/bin/ag',
      \   JavaClassnameList: {-> readfile('/home/jmend/.vim/java-classnames')},
      \   ClasspathJarList: {-> systemlist('fish -c "classpath list"')},
      \   google_java_executable: 'google-java-format --skip-javadoc-formatting',
      \ }

" Defines the import cache used for Java import search, if an attempt to
" resolve the import for a key in this map, the value specified will be
" imported before trying any other method to find the import.
let g:jm_vimrc.java_import_cache = #{
      \   Map: 'java.util.Map',
      \   Set: 'java.util.Set',
      \   Stream: 'java.util.stream.Stream',
      \   Collectors: 'java.util.stream.Collectors',
      \   List: 'java.util.List',
      \   ArrayList: 'java.util.ArrayList',
      \   Optional: 'java.util.Optional',
      \   HashSet: 'java.util.HashSet',
      \   HashMap: 'java.util.HashMap',
      \   Collection: 'java.util.Collection',
      \   Consumer: 'java.util.function.Consumer',
      \   Function: 'java.util.function.Function',
      \   Supplier: 'java.util.function.Supplier',
      \   ImmutableList: 'com.google.common.collect.ImmutableList',
      \   ImmutableSet: 'com.google.common.collect.ImmutableSet',
      \   toImmutableList: 'static com.google.common.collect.ImmutableList.toImmutableList',
      \   toImmutableSet: 'static com.google.common.collect.ImmutableSet.toImmutableSet',
      \   ImmutableMap: 'com.google.common.collect.ImmutableMap',
      \   Provider: 'javax.inject.Provider',
      \   Inject: 'javax.inject.Inject',
      \   Qualifier: 'javax.inject.Qualifier',
      \   Singleton: 'javax.inject.Singleton',
      \   Binds: 'dagger.Binds',
      \   Module: 'dagger.Module',
      \   Component: 'dagger.Component',
      \   Provides: 'dagger.Provides',
      \   Multibinds: 'dagger.multibindings.Multibinds',
      \   IntoSet: 'dagger.multibindings.IntoSet',
      \   IntoMap: 'dagger.multibindings.IntoMap',
      \   IntKey: 'dagger.multibindings.IntKey',
      \   LongKey: 'dagger.multibindings.LongKey',
      \   StringKey: 'dagger.multibindings.StringKey',
      \   ClassKey: 'dagger.multibindings.ClassKey',
      \   ElementsIntoSet: 'dagger.multibindings.ElementsIntoSet',
      \   MapKey: 'dagger.MapKey',
      \ }
" }}}

" Playground: {{{
for [key, path] in items(#{
      \   v: '~/.vimrc',
      \   l: '~/minecraft/logs/latest.log',
      \   j: '~/state/jems',
      \ })
  execute printf('nnoremap <leader>e%s :edit %s<cr>', key, path)
endfor
" }}} Playground

" Plugins (vim-plug): {{{
call plug#begin('~/.vim/bundle')

" Plugins:
Plug 'morhetz/gruvbox'
Plug 'tpope/vim-surround'
Plug 'scrooloose/nerdtree'
Plug 'godlygeek/tabular'
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'junegunn/fzf', {'do': {-> fzf#install()}}
Plug 'junegunn/fzf.vim'
Plug 'tpope/vim-fugitive'
Plug 'moll/vim-bbye'
Plug 'scrooloose/nerdcommenter'
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-repeat'
Plug 'triglav/vim-visual-increment'
Plug 'tmhedberg/SimpylFold'
Plug 'majutsushi/tagbar'
Plug 'pangloss/vim-javascript'
Plug 'nelstrom/vim-markdown-folding'
Plug 'justinmk/vim-syntax-extra'
Plug 'jpalardy/vim-slime'
Plug 'itchyny/lightline.vim'
Plug 'ap/vim-buftabline'
Plug 'airblade/vim-gitgutter'
Plug 'google/vim-maktaba'
Plug 'google/vim-codefmt'
Plug 'google/vim-glaive'
Plug 'jmend736/basis', { 'rtp': 'vim' }

" Plug 'mattn/emmet-vim'
" Plug 'sheerun/vim-polyglot'
" Plug 'fatih/vim-go'
" Plug 'davidhalter/jedi-vim'
" Plug 'ervandew/supertab'
" Plug 'w0rp/ale'
" Plug 'Valloric/YouCompleteMe'
" Plug 'neoclide/coc.nvim', {'branch': 'release'}
" http://eclim.org
call plug#end()

if !exists('g:loaded_plug')
  echoerr "ERROR: vim-plug is REQUIRED https://github.com/junegunn/vim-plug"
  finish
endif


call glaive#Install()

Glaive codefmt google_java_executable=`g:jm_vimrc.deps.google_java_executable`

" }}} Plugins (Vundle)

" General Options: {{{
set nocompatible
filetype plugin indent on

set t_Co=256
set t_ut=

" Sets the shell to use
set shell=/bin/bash

" Allows you to define a .vimrc or .exrc in the CWD
" while disallowing the use of :autocmd in that rc
"set exrc
"set secure

" Specifies the behavior of buffers when they are sent to an `inactive` state.
" An `inactive` state is one in which there is no window displaying that
" buffer. The 'bufhidden' option allows defining what action to take when a
" buffer is about to be hidden. Using `bufhidden=delete` allows a buffer to be
" removed once the window is closed OR used for something else. See
" windows.txt for more information about the nuances between 'hidden' and the
" various window-modifying functions
set hidden

" Tabs
set tabstop=2  " col-size of tabs
set shiftwidth=2  " sets what >> and << ops do
set expandtab  " replace tabs with spaces
set smarttab  " More reasonable tab actions

" Reasonable backspace functionality
set backspace=indent,eol,start

" Replace certain characters visually
set listchars=tab:\>\ ,trail:·
set list

" Line number things
set number
set numberwidth=4
set relativenumber

" Show info
set ruler
set showcmd
set statusline=%f\ %=L:%l/%L\ %c\ (%p%%)

" Tab completion for : command
set wildmenu
set wildmode=longest,list,full

" Highlight search + incremental search
set hlsearch
set incsearch

" Ignore case, unless you use uppercase characters
set ignorecase
set smartcase

" Other
set fileencodings=utf-8
set tags=tags
set printoptions=number:y,duplex:long,paper:letter
set clipboard=unnamedplus
set errorbells
set laststatus=2
set cursorline
set sessionoptions=
      \buffers,
      \blank,
      \curdir,
      \folds,
      \help,
      \localoptions,
      \options,
      \tabpages,
      \winsize,
      \terminal

" Themes
colorscheme gruvbox
syntax enable
set bg=dark
" }}} General Settings

" Plugin Settings: {{{

let g:lightline = {
            \   'active': {
            \     'left': [['mode', 'paste'], ['filename', 'modified']],
            \     'right': [['winid_bufnr', 'lineinfo'], ['percent'], ['readonly']]
            \   },
            \   'inactive': {
            \     'left': [['filename', 'modified']],
            \     'right': [['winid_bufnr', 'lineinfo'], ['readonly']]
            \   },
            \   'component_type': {
            \     'readonly': 'error',
            \   },
            \   'component': {
            \     'winid_bufnr': '%{win_getid()}{%{bufnr()}}'
            \   },
            \ }

let g:slime_target = "tmux"

let g:vim_markdown_new_list_item_indent = 0
let g:vim_markdown_folding_disabled = 1

" Use ordinal numbers (2) rather than bufnum (1)
let g:buftabline_numbers = 2
let g:buftabline_indicators = v:true
let g:buftabline_separators = v:false

let g:netre_liststyle=3

let g:tex_flavor='latex'

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
let g:UltiSnipsEditSplit="vertical"

let g:gitgutter_sign_added = '··'
let g:gitgutter_sign_modified = '··'
let g:gitgutter_sign_removed = '·'
let g:gitgutter_sign_modified_removed = '·'
" }}} Plugin Settings

" Keymappings: {{{

" Moves around a line more closely to what is expected (at least by me) when
" the line is wrapped.
"nnoremap j gj
"nnoremap k gk
"vnoremap j gj
"vnoremap k gk

" Moving around between windows quickly
noremap <C-j> <C-W>j
noremap <C-k> <C-W>k
noremap <C-h> <C-W>h
noremap <C-l> <C-W>l

nnoremap <leader>q :Bdelete<cr>
nnoremap <leader>' :NERDTreeToggle<cr>
nnoremap <leader>" :NERDTreeFind<cr>
nnoremap <leader><tab> :TagbarToggle<cr>

inoremap <C-r><C-f> <C-r>=expand('%:t:r')<cr>

nnoremap <C-p> :Files<cr>

nnoremap <silent> <leader>w :nohlsearch<Bar>:echo<cr>

noremap <F11> :syntax spell toplevel<cr>
noremap <F12> :setlocal spell! spelllang=en_us<cr>

nnoremap <leader>j :Javap! <cword><CR>
nnoremap <leader>g :Git<cr>

nnoremap <C-w><C-z> :Sz 10<cr>
nnoremap <C-w>z :Sz 10<cr>

nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

nnoremap <leader>t :tags<cr>
nnoremap <leader><leader> :tags<cr>

nnoremap <leader>S :mksession<cr>

nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)
" }}} Keymappings

" Commands: {{{

" Command :Term ~ Nicer :term API
" :Term ~ Runs 'shell'
" :Term [command]... ~ Runs the command in 'shell'
"
" This command will reuse the last window, unless it's no longer being used
" for the terminal buffer. Also, this hides the buffer, in case you leave a
" terminal window running and don't want to accidentally get stuck in it.
if !exists('g:jm_term')
  let g:jm_term = bss#view#TermView()
endif
command! -nargs=* Term call g:jm_term.Run(<q-args>)

command! SetupClasspath
      \ let $CLASSPATH = join(g:jm_vimrc.deps.ClasspathJarList(), ':')
command! SetupTargetClasspath
      \ let $CLASSPATH = s:TargetClasspath()
command! -nargs=1 Sz
      \ resize <args> | set winfixheight

command! WtfMark
      \ echo "'[ '] prev. changed or yanked yext" |
      \ echo "'< '> prev. selected visual area" |
      \ echo "'.    Last change start" |
      \ echo "]' [' Move to next/prev mark"

command! -nargs=+ ReplaceR call s:ReplaceR(<q-args>)
function! s:ReplaceR(cmd) abort
call execute(printf(
    \ 'nnoremap <buffer> <localleader>r :Term %s<cr>',
    \ a:cmd))
endfunction

" The Silver Searcher
if executable('ag')
    " Use ag over grep
    set grepprg=ag\ --nogroup\ --nocolor\ --ignore=tags
endif
" }}} Commands

" FT-Specific Settings: {{{

" Autocommands are split into filetype `augroup`s, each is separated by
" filetype. This solves the problem of sourcing the vimrc multiple times
" causing multiple duplicated autocommands to be set. An augroup is only run
" once**.
"
" These keymappings depend on the filetype, when :filetype on is enabled (as
" it is earlier in this config), when vim first loads a buffer, it will
" automatically detect the filetype and set the 'filetype' option (buffer)
" locally. After this happens, any `FileType` type autocommands are triggered
"
" NOTES:
" ** An augroup doesn't provide this functionality by itself. When you
" redefine it, it will 'add onto' the original one, in order to clear one, you
" can add `autocommand!` or `au!` to it (or another with the same name). This
" is used to make sure that only one version of the autocommand hooks is set
" per buffer.
augroup ft_latex
    autocmd!
    autocmd FileType tex setlocal nocursorline
    autocmd FileType tex setlocal tabstop=2 shiftwidth=2
    autocmd FileType tex nnoremap <buffer> <localleader>r
                \ :Term pdflatex -halt-on-error %<cr>
augroup END

augroup ft_c
    autocmd!
    autocmd FileType c setlocal tabstop=2 shiftwidth=2
    autocmd FileType c nnoremap <buffer> <localleader>r
                \ :make<CR>
    autocmd FileType c nnoremap <buffer> <localleader>R
                \ :Term gcc -Wall -O3 -o a.out %;./a.out;rm a.out<cr>
augroup END


augroup ft_cc
    autocmd!
    autocmd FileType cpp setlocal tabstop=2 shiftwidth=2
    autocmd FileType cpp nnoremap <buffer> <localleader>r
                \ :make<CR>
    autocmd FileType cpp nnoremap <buffer> <localleader>R
                \ :Term g++ -Wall -O3 -o a.out %;./a.out;rm a.out<cr>
augroup END

augroup ft_python
    autocmd!
    autocmd FileType python nnoremap <buffer> <localleader>r
                \ :execute "Term blaze run " .. join(<SID>BlazeTargets(expand("%")), " ")<cr>
    autocmd FileType python nnoremap <buffer> <localleader>t
                \ :execute "Term mypy --ignore-missing-imports --follow-imports=skip " .. expand("%")<cr>
    autocmd FileType python nnoremap <buffer> <localleader>f
                \ :FormatCode<cr>
augroup END

augroup ft_scheme
    autocmd!
    autocmd FileType scheme setlocal colorcolumn=79
    autocmd FileType scheme nnoremap <buffer> <localleader>r
                \ :w<CR> :Term mit-scheme --load % <CR>
augroup END

augroup ft_java
    autocmd!
    autocmd FileType java
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType java nnoremap <space>f :FormatCode<cr>
    autocmd FileType java vnoremap <space>f :FormatLines<cr>
    autocmd FileType java nnoremap <silent> <buffer> <localleader>r
          \ :execute "Term make"<cr>
    autocmd FileType java nnoremap <silent> <buffer> <localleader>R
          \ :execute "Term blaze run " .. join(<SID>BlazeTargets(expand("%")), " ")<cr>
    autocmd FileType java let b:surround_99 = "{@code \r}"
augroup END

augroup ft_javascript
    autocmd!
    autocmd FileType javascript
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType javascript nnoremap <buffer> <localleader>r
          \ :w<CR> :!node %<CR>
    autocmd FileType javascript nnoremap <buffer> <localleader>R
          \ :Term webpack<CR>
augroup END

augroup ft_markdown
    autocmd!
    autocmd FileType markdown nnoremap <buffer> ]h :<c-u>call search('\v^#+ ', 'Wz')<cr>
    autocmd FileType markdown nnoremap <buffer> [h :<c-u>call search('\v^#+ ', 'bWz')<cr>
    autocmd FileType markdown highlight htmlH1 ctermfg=DarkRed
    autocmd FileType markdown highlight htmlH2 ctermfg=DarkCyan
    autocmd FileType markdown highlight htmlH3 ctermfg=DarkGreen
    autocmd FileType markdown highlight htmlH4 ctermfg=LightGray
    autocmd FileType markdown highlight def link mkdHeading GruvboxAquaBold
    autocmd FileType markdown syntax clear markdownCodeBlock
    autocmd FileType markdown nnoremap <buffer> <leader>r
                \ :Term pandoc %:p -s --highlight-style kate --pdf-engine=xelatex -o gen/%:t:r.pdf<cr>
augroup END

augroup ft_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker shiftwidth=2
    autocmd FileType vim nnoremap <buffer> <localleader>r
          \ :source %<cr>
augroup END

augroup ft_fish
    autocmd!
    autocmd FileType fish setlocal tabstop=4 shiftwidth=4 smartindent
    autocmd FileType fish nnoremap <buffer> <space>f
          \ :0,$!fish_indent<cr>
augroup END

" Use quickfix window when using :make
augroup cfg_quickfix_fix
    autocmd QuickFixCmdPost [^l]* nested cwindow
    autocmd QuickFixCmdPost    l* nested lwindow
augroup end

" }}} FT-Specific Settings

" Misc: {{{

" :FindImport {Classname}
"   Attempt to find and a Java import statement for the {Classname}
"     1. Try the `g:jm_vimrc.java_import_cache`
"     2. Search the CWD using `ag` for an `import .*\.{ClassName};`
"     3. Finally, search `g:jm_vimrc.deps.JavaClassnameList()`
" {{{
nnoremap <space>t :call <SID>FindImport(expand('<cword>'))<CR>
command -nargs=1 FindImport call <SID>FindImport(<q-args>)
function! s:FindImport(word) abort
  " First try the g:jm_vimrc.java_import_cache
  if (has_key(g:jm_vimrc.java_import_cache, a:word))
    call s:AddImport(printf('import %s;', get(g:jm_vimrc.java_import_cache, a:word)))
    return
  endif

  " Next find an import statement in the current directory
  let l:results = systemlist(printf(
        \ '%s --nofilename --nobreak ''import .+\b%s\b;''',
        \ g:jm_vimrc.deps.ag,
        \ a:word))->sort()->uniq()

  " Finally, fallback to classname list
  if empty(l:results)
    let l:results = g:jm_vimrc.deps.JavaClassnameList()
          \->filter('v:val =~# a:word')
          \->map('"import " .. v:val .. ";"')
  endif

  if len(l:results) == 1
    call s:AddImport(l:results[0])
  elseif len(l:results) > 1
    call maktaba#ui#selector#Create(l:results)
          \.WithMappings({'<cr>': [function("s:AddImport")->get("name"), 'Close', 'Add import']})
          \.Show()
  endif
endfunction

function! s:AddImport(import) abort
    call append(1, [a:import])
    execute '1,1FormatLines'
    echom "Adding: " .. a:import
endfunction
" }}}

" :Javap {qualified-classname}
"   Run `javap` against the provided classname
" {{{
command! -nargs=? -complete=customlist,<SID>JavapComplete -bang
      \ Javap call <SID>Javap(<q-args>, "<bang>" ==# '!')
function! s:Javap(arg, search) abort
  if empty($CLASSPATH)
    SetupClasspath
  endif

  let l:cls = empty(a:arg) ? @" : a:arg
  let l:cls = substitute(l:cls, '\(;\|<.\+>\)', '', 'ga')

  if a:search
    let l:results = s:JavapComplete(l:cls, v:none, v:none)
    if len(l:results) == 1
      let l:cls = l:results[0]
    else
      call maktaba#ui#selector#Create(l:results)
            \.WithMappings({'<cr>': [function("s:JavapOpen")->get("name"), 'Close', 'Open window']})
            \.Show()
      return
    endif
  endif

  call g:jm_term
        \.Run([g:jm_vimrc.deps.javap, l:cls])
        \.Exec('set ft=java')
endfunction

function! s:JavapComplete(arg_lead, cmd_line, cursor_pos) abort
  return g:jm_vimrc.deps.JavaClassnameList()
        \->filter('v:val =~# a:arg_lead')
endfunction

function! s:JavapOpen(cls) abort
  execute 'Javap ' .. a:cls
endfunction
" }}}

" :MavenSearch {query}
" :M {query}
"   Run a maven query, and show results in a selector window
" {{{
command! -nargs=1 MavenSearch call <SID>MavenSearch(<q-args>)
command! -nargs=1 M MavenSearch <args>
function! s:MavenSearch(query) abort
  const l:query_url = printf(
        \ 'https://search.maven.org/solrsearch/select?q=%s&rows=10&wt=json',
        \ a:query)

  const l:query_cmd = join([
        \   g:jm_vimrc.deps.curl,
        \   '-s',
        \   printf('"%s"', l:query_url),
        \ ])

  let l:msg = system(l:query_cmd)
  let l:resp = json_decode(l:msg).response

  if l:resp.numFound == 0
    echom "None found!"
    return
  endif
  let l:docs = l:resp.docs
  const l:mappings = {
        \   '<cr>': [function("s:Insert")->get("name"), 'Close', 'Insert below'],
        \ }
  call maktaba#ui#selector#Create(map(l:docs, 'v:val.id .. ":" .. v:val.latestVersion'))
        \.WithMappings(l:mappings)
        \.Show()
endfunction

function! s:Insert(msg) abort
  let l:spaces = getline('.')->matchstr('^\s*')
  call append(line('.'), printf("%simplementation '%s'", l:spaces, a:msg))
endfunction
" }}}

" Bazel/Blaze helper functions
"
"   s:BlazeTargets({fname})
"     Return the targets that depend on {fname} directly
"
"   BlazeTarget()
"     Returns the first target for the current file
"
"   s:TargetClasspath()
"     Returns the classpath for BlazeTarget()
"
"   s:CompleteTargets({arg_lead}, {cmd_line}, {cursor_pos})
"     A -complete=customlist compatible function that simply filters the
"     commandline against all targets
"
" {{{
function! s:BlazeTargets(fname) abort
  let l:query = printf(
        \   'same_pkg_direct_rdeps("//%s:%s")',
        \   fnamemodify(a:fname, ":.:h:r"),
        \   fnamemodify(a:fname, ":t"),
        \ )

  let l:command = printf(
        \   "%s query '%s'",
        \   g:jm_vimrc.deps.blaze,
        \   l:query,
        \ )
  echom l:command
  return filter(systemlist(l:command), 'v:val =~# "^//"')
endfunction

function! BlazeTarget() abort
  return get(s:BlazeTargets(expand('%:p')), 0, "???")
endfunction

function! s:TargetClasspath() abort
  let l:target = BlazeTarget()
  if l:target ==# "???"
    echom "Can't find blaze target!"
    return ""
  endif

  let l:lines = systemlist(printf('blaze print_action "%s"', l:target))
  let l:jars = filter(l:lines, {_, v -> v =~# '^\s\+\(outputjar\|classpath\): "[^"]*"'})
        \->map({_, v -> matchlist(v, '"\([^"]*\)"')[1]})
  return join(l:jars, ':')
endfunction

function! s:CompleteTargets(arg_lead, cmd_line, cursor_pos) abort
  if a:arg_lead =~ '^//.*'
    return systemlist(printf('%s query ... 2>&1', g:jm_vimrc.deps.blaze))
          \->filter('v:val =~# "' .. a:arg_lead .. '"')
  endif
endfunction
" }}}

" :Touch {path}...
"   Like `$ touch`, but also create directories if necessary
" {{{
command! -nargs=* Touch call s:Touch([<f-args>])
function! s:Touch(paths) abort
  for l:path in a:paths
    let l:dir = fnamemodify(l:path, ':h')
    if l:dir !=# '.' && !isdirectory(l:dir)
      call system('mkdir -p ' .. shellescape(l:dir))
    endif
    if !filereadable(l:path)
      call system('touch ' .. shellescape(l:path))
    endif
  endfor
endfunction
" }}}

" }}} Misc
