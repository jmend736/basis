" Copyright (c) 2026 Julian Mendoza;
"
" MIT License
"
" Permission is hereby granted, free of charge, to any person obtaining a copy
" of this software and associated documentation files (the "Software"), to deal
" in the Software without restriction, including without limitation the rights
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
" copies of the Software, and to permit persons to whom the Software is
" furnished to do so, subject to the following conditions:
"
" The above copyright notice and this permission notice shall be included in all
" copies or substantial portions of the Software.
"
" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
" SOFTWARE.

""
" jmend's vimrc!
"
" Self Link: jmend.io/vimrc
"
" Installing Required Plugins:
"   1. Install vim-plug: https://github.com/junegunn/vim-plug
"   2. Run :PlugInstall
"   3. Restart vim
"
" Self-Documentation:
"   :Wtf commands ~ Show commands set in this vimrc
"   :Wtf mappings ~ Show mappings set in this vimrc
"   :Wtf <tab>    ~ Show other documentation available
"                   (Mostly misc. stuff I find useful to remember)

" Required here for vim9+
set nocompatible

" Command Prefix:
"   <leader>      : used for global mappings
"   <localleader> : used for buffer-local mappings
let mapleader = '\'
let maplocalleader = '\'

" System Dependencies: {{{
let g:jm_vimrc = {}

" Will store documentation
" Accessible with the :Wtf command
let g:jm_vimrc.docs = {}

" Map from defined commands to description
" See :Wtf commands
let g:jm_vimrc.docs.commands = {}

" Map from defined mappings to description
" See :Wtf mappings
let g:jm_vimrc.docs.mappings = {}

" A variety of dependencies on the system
let g:jm_vimrc.deps = #{
      \   jshell: 'jshell',
      \   curl:   'curl',
      \   blaze:  'blaze',
      \   javap:  'javap',
      \   ag:     'ag',
      \   fish:   'fish',
      \   python: 'python3',
      \ }

" Whether this computer is a mac
let g:jm_vimrc.is_mac = system('uname -s') =~# 'Darwin'

" Whether python is supported
let g:jm_vimrc.has_python = has('python3')

" Some system dependencies
let g:jm_vimrc.deps.JavaClassnameList      = {-> systemlist('fish -c "classpath list-all-classes"')}
let g:jm_vimrc.deps.ClasspathJarList       = {-> systemlist('fish -c classpath')}
"let g:jm_vimrc.deps.google_java_executable = 'google-java-format --skip-javadoc-formatting'
let g:jm_vimrc.deps.google_java_executable = 'google-java-format'
let g:jm_vimrc.deps.buildozer   = 'fish -c buildozer'
" }}}

" Playground: {{{
let s:pg_items = (g:jm_vimrc.is_mac)
      \ ? #{
      \     co: 'Files ~/Playground',
      \     cj: 'Files ~/Playground/jdk/src/java.base/share/classes',
      \     pg: 'Files ~/Playground',
      \     n:  'Files ~/Playground/jmendio/n',
      \     v:  'edit ~/.vimrc',
      \   }
      \ : #{
      \     a:  'Files ~/code/abseil-cpp/absl',
      \     co: 'Files ~/code',
      \     cg: 'Files ~/code/guava/guava/src',
      \     cj: 'Files ~/code/jdk/src/java.base/share/classes',
      \     cv: 'Files ~/code/opencv/modules/core',
      \     cp: 'Files ~/code/pandas',
      \     cd: 'Files ~/code/dagger',
      \     cb: 'Files ~/code/basis',
      \     cO: 'Files /usr/lib/ocaml',
      \     j:  'Files ~/junk',
      \     n:  'Files ~/jmendio/n',
      \     v:  'edit ~/.vimrc',
      \   }
for [key, path] in items(s:pg_items)
  execute printf('nnoremap <leader>e%s :%s<cr>', key, path)
  let g:jm_vimrc.docs.mappings['\e' .. key] = 'Run :' .. path
endfor
" }}} Playground

" Plugins (vim-plug): {{{
call plug#begin('~/.vim/bundle')

"" Plugins:
Plug 'morhetz/gruvbox'
Plug 'tpope/vim-surround'
Plug 'scrooloose/nerdtree'
Plug 'godlygeek/tabular'
if g:jm_vimrc.has_python
  Plug 'SirVer/ultisnips'
  Plug 'Valloric/YouCompleteMe'
endif
Plug 'honza/vim-snippets'
Plug 'junegunn/fzf', {'do': {-> fzf#install()}}
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-fugitive'
Plug 'moll/vim-bbye'
Plug 'scrooloose/nerdcommenter' " \c<Space> \cc
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-repeat'
Plug 'triglav/vim-visual-increment'
Plug 'tmhedberg/SimpylFold'
Plug 'majutsushi/tagbar'
Plug 'pangloss/vim-javascript'
Plug 'justinmk/vim-syntax-extra'
Plug 'jpalardy/vim-slime'
Plug 'itchyny/lightline.vim'
Plug 'ap/vim-buftabline'
Plug 'airblade/vim-gitgutter'
Plug 'google/vim-maktaba'
Plug 'google/vim-codefmt'
Plug 'google/vim-glaive'
Plug 'frazrepo/vim-rainbow'
Plug 'AndrewRadev/splitjoin.vim' " gS gJ
Plug 'AndrewRadev/linediff.vim'
Plug 'shiracamus/vim-syntax-x86-objdump-d'
if isdirectory('$OCAML_OCP_INDENT')
  Plug $OCAML_OCP_INDENT
endif
if exists("$BASIS")
  Plug $BASIS, { 'rtp': 'vim' }
else
  Plug 'jmend736/basis', { 'rtp': 'vim' }
endif

"" Old Plugins:
" Plug 'vim-scripts/DrawIt'
" Plug 'cohama/lexima.vim'
" Plug 'mattn/emmet-vim'
" Plug 'sheerun/vim-polyglot'
" Plug 'fatih/vim-go'
" Plug 'davidhalter/jedi-vim'
" Plug 'ervandew/supertab'
" Plug 'w0rp/ale'
" Plug 'neoclide/coc.nvim', {'branch': 'release'}
" http://eclim.org
" Plug 'bazelbuild/vim-ft-bzl'
" -> https://github.com/bazelbuild/vim-ft-bzl/commit/941fb142f604c254029c2a0852ea7578f08de91a
" Plug 'nelstrom/vim-markdown-folding'
" Plug 'romainl/vim-devdocs'

"" Plugins to check out:
" Plug 'liuchengxu/vista.vim'
" Plug 'natebosch/vim-lsc'
" Plug 'chrisbra/NrrwRgn'
" Plug 'justinmk/vim-sneak'
" Plug 'romainl/vim-qf'
" Plug 'romainl/vim-qlist'
" Plug 'mbbill/undotree'
" Plug 'wellle/targets.vim'
call plug#end()

if !exists('g:loaded_plug')
  echoerr "ERROR: vim-plug is REQUIRED https://github.com/junegunn/vim-plug OR :InstallPlug"
  command InstallPlug execute printf('term curl -fLo %s/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim', $HOME)
  finish
endif


call glaive#Install()

Glaive codefmt
      \ google_java_executable=`g:jm_vimrc.deps.google_java_executable`
      \ clang_format_style='Google'

" }}} Plugins (Vundle)

" General Options: {{{
filetype plugin indent on

set t_Co=256        " Number of colors
set t_ut=           " Use current background color for clearing

set scrolloff=0     " Minimal number of screen lines to keep above/below cursor

set shell=/bin/bash " Sets the shell to use

set hidden          " Whether to allow modified buffers to be hidden

set tabstop=2       " Number of spaces that a read <Tab> counts for
set softtabstop=2   " Number of spaces an inserted <Tab> counts for
set shiftwidth=2    " Sets what >> and << ops do
set expandtab       " Replace tabs with spaces when editing
set smarttab        " More reasonable tab actions

set autoindent      " Copy indent from current line when starting a new line
set smartindent     " Adds indents after {, or 'cinwords'

                    " Reasonable backspace functionality
set backspace=indent,eol,start

set list            " Replace certain characters visually
set listchars=tab:\>\ ,trail:·,extends:→,precedes:←

set number           " Show line number at cursor,
set numberwidth=4    " with a column width of 3,
set relativenumber   " and numbers relative to cursor elsewhere
set noruler          " Show line/col number (hidden by lightline)
set showcmd          " Show currently entered command below status
                     " Define status line (hidden by lightline)
set statusline=%f\ %=L:%l/%L\ %c\ (%p%%)

set wildmenu         " Tab completion for : command
set wildmode=longest,list,full

set hlsearch         " Highlight search results
set incsearch        " Highlight while searching
set foldopen-=search " Whether to open folds when searching
                     " Also see :ToggleFoldOpenSearch
set foldlevel=999    " Start with all folds open

" Ignore case, unless you use uppercase characters
set ignorecase
set smartcase

" Other
set fileencodings=utf-8
set tags=tags
set tags+=/usr/include/**/tags
set printoptions=number:y,duplex:long,paper:letter
if g:jm_vimrc.is_mac
  set clipboard=unnamed
else
  set clipboard=unnamedplus
endif
set errorbells
set laststatus=2
set cursorline
set sessionoptions=
      \blank,
      \curdir,
      \folds,
      \help,
      \localoptions,
      \options,
      \tabpages,
      \winsize,
      \terminal

set directory=~/.swaps//

" Some mathematical digraphs
digraphs el 8712 " Element in
digraphs in 8712 " Element in
digraphs ni 8713 " element not in
digraphs es 8709 " Empty Set
digraphs ss 8834 " Subset
digraphs se 8838 " Subset equals
digraphs ns 8836 " Not subset
digraphs nS 8840 " Not subset equals
digraphs nn 8745 " Intersection
digraphs uu 8746 " Union
digraphs un 8746 " Union
digraphs co 8728 " Composition
digraphs \|> 8614 " Maps to
digraphs tl 8598 " Diagonal arrow top-left
digraphs tr 8599 " Diagonal arrow top-right
digraphs br 8600 " Diagonal arrow bot-right
digraphs bl 8601 " Diagonal arrow bot-left
digraphs -u 8593 " Up arrow
digraphs -d 8595 " down arrow
digraphs c. 183  " center dot
digraphs .. 183  " center dot
digraphs T- 8866  " Turnstile (right) |-
digraphs -T 8867  " Turnstile (left) -|
digraphs =v 8659  " Downwards double arrow

" Themes
colorscheme gruvbox
syntax enable
set bg=dark
" }}} General Settings

" Plugin Settings: {{{

let g:lightline = {
      \   'active': {
      \     'left': [['mode', 'paste'], ['filename', 'modified']],
      \     'right': [['winlayout', 'winid_bufnr', 'lineinfo'], ['percent', 'foldlevel'], ['readonly']]
      \   },
      \   'inactive': {
      \     'left': [['filename', 'modified']],
      \     'right': [['winlayout', 'winid_bufnr', 'lineinfo'], ['readonly']]
      \   },
      \   'component_type': {
      \     'readonly': 'error',
      \   },
      \   'component': {
      \     'winid_bufnr': '[%{winnr()}/%{win_getid()}(%{Layout()[win_getid()]})]{%{bufnr()}}',
      \     'foldlevel': '%{(&foldenable) ? &foldlevel : "-"}f',
      \   },
      \ }

let $FZF_DEFAULT_COMMAND = 'ag -l'

let g:html_dynamic_folds = v:true

let g:ycm_auto_trigger = 1
let g:ycm_disable_signature_help = 1
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']

let g:slime_target = "tmux"

" Will disable indent-based markdown code blocks
let g:bss_markdown_fix = 1

let g:bss_java_fix = 1

let g:markdown_folding = 1

let g:NERDCompactSexyComs = v:true
let g:NERDCommentEmptyLines = v:true
let g:NERDDefaultAlign = 'left'

let g:tagbar_sort = v:false

" Use ordinal numbers (2) rather than bufnum (1)
let g:buftabline_numbers = 2
let g:buftabline_indicators = v:true
let g:buftabline_separators = v:false

let g:netre_liststyle=3

let g:tex_flavor='latex'

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
let g:UltiSnipsEditSplit="vertical"

let g:gitgutter_sign_added = '··'
let g:gitgutter_sign_modified = '··'
let g:gitgutter_sign_removed = '·'
let g:gitgutter_sign_modified_removed = '·'
" }}} Plugin Settings

" Keymappings: {{{
"   To understand keys see :h key-notation

" By default, `j` and `k` will move between lines; this means they will skip
" over multiple lines when lines wrap.
"
" Uncomment the 4 lines below so that `j` and `k` move between lines on the
" screen.
"nnoremap j gj
"nnoremap k gk
"vnoremap j gj
"vnoremap k gk

" Moving around between windows quickly
let g:jm_vimrc.docs.mappings['<C-[hjkl]>'] =
      \ 'Move between windows by holding CTRL'
noremap <C-j> <C-W>j
noremap <C-k> <C-W>k
noremap <C-h> <C-W>h
noremap <C-l> <C-W>l

let g:jm_vimrc.docs.mappings['<C-[←↑↓→]>'] =
      \ 'Move visual selection'
vnoremap <C-Up> koko
vnoremap <C-Down> jojo
vnoremap <C-Left> hoho
vnoremap <C-Right> lolo

let g:jm_vimrc.docs.mappings['[['] =
      \ 'Enable [[,][,]],[] to operate on non-col-1-{}'
" From :h object-motions
nnoremap [[ ?{<CR>w99[{
nnoremap ][ /}<CR>b99]}
nnoremap ]] j0[[%/{<CR>
nnoremap [] k$][%?}<CR>

let g:jm_vimrc.docs.mappings['\q'] =
      \ 'Delete current buffer without changing window layout'
nnoremap <leader>q :Bdelete<cr>

let g:jm_vimrc.docs.mappings["\\'"] =
      \ 'Open NERDTree (file explorer)'
nnoremap <leader>' :NERDTreeToggle<cr>

let g:jm_vimrc.docs.mappings['\"'] =
      \ 'Open NERDTree (file explorer) to current file'
nnoremap <leader>" :NERDTreeFind<cr>

let g:jm_vimrc.docs.mappings['\<Tab>'] =
      \ 'Open Tagbar'
nnoremap <leader><tab> :TagbarToggle<cr>

let g:jm_vimrc.docs.mappings['<F10>'] =
      \ 'Toggle paste'
set pastetoggle=<F10>

let g:jm_vimrc.docs.mappings['<F9>'] =
      \ 'Toggle virtualedit=all'
nnoremap <F9> :let &ve = <C-r>=empty(&ve) ? '"all"' : '""'<cr><cr>

let g:jm_vimrc.docs.mappings['<C-r><C-f>'] =
      \ '[modes:ic] Insert file name root'
inoremap <C-r><C-f> <C-r>=expand('%:p:t:r')<cr>
cnoremap <C-r><C-f> <C-r>=expand('%:p:t:r')<cr>

let g:jm_vimrc.docs.mappings['<C-r><C-t>'] =
      \ '[modes:ic] Insert file name root'
inoremap <C-r><C-t> <C-r>=bss#blaze#BlazeTarget()<cr>
cnoremap <C-r><C-t> <C-r>=bss#blaze#BlazeTarget()<cr>

let g:jm_vimrc.docs.mappings['<C-p>'] =
      \ 'Fuzzy-search PWD'
nnoremap <C-p> :Files<cr>

let g:jm_vimrc.docs.mappings['\w'] =
      \ 'Clear search highlights (:nohlsearch)'
nnoremap <silent> <leader>w :nohlsearch<Bar>:echo<cr>

let g:jm_vimrc.docs.mappings['<F11>'] =
      \ 'Ensure non-syntax toplevel text is spell-checked'
noremap <F11> :syntax spell toplevel<cr>
let g:jm_vimrc.docs.mappings['<F12>'] =
      \ 'Toggle spell checking'
noremap <F12> :setlocal spell! spelllang=en_us<cr>

let g:jm_vimrc.docs.mappings['<Space>l'] =
      \ 'Open Git ("Change [L]ist")'
nnoremap <leader>l :Git<cr>

let g:jm_vimrc.docs.mappings['<C-w><C-z>'] =
      \ 'Set window height to 10 and fix the height'
nnoremap <C-w><C-z> :FixHeight 10<cr>
nnoremap <C-w>z :FixHeight 10<cr>

let g:jm_vimrc.docs.mappings['K'] =
      \ 'Do grep for word under cursor'
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

let g:jm_vimrc.docs.mappings['\\'] =
      \ 'Show :tags'
nnoremap <leader><leader> :tags<cr>

let g:jm_vimrc.docs.mappings['\s'] =
      \ 'Refresh UltSnips snippets'
nnoremap <leader>s :call UltiSnips#RefreshSnippets()<cr>

let g:jm_vimrc.docs.mappings['\<Space>'] =
      \ 'Toggle foldcolumn'
nnoremap <leader><space> :let &l:foldcolumn = (&l:foldcolumn) ? 0 : 3<cr>

let g:jm_vimrc.docs.mappings['\a'] =
      \ 'Trigger EasyAlign (See :Wtf ea)'
xmap <leader>a <Plug>(EasyAlign)
nmap <leader>a <Plug>(EasyAlign)

let g:jm_vimrc.docs.mappings['\O'] =
      \ 'Run `open %`'
xmap <leader>O :<C-u>!open %<cr>
nmap <leader>O :<C-u>!open %<cr>

let g:jm_vimrc.docs.mappings["C-W !"] =
      \ 'Toggle buflisted'
nnoremap <C-W>l :set buflisted!<cr>

nnoremap <space>c  :YcmCompleter GetType<cr>
nnoremap <space>cq :YcmCompleter GoToDocumentOutline<cr>
nnoremap <space>cc :YcmCompleter GoToCallers<cr>
nnoremap <space>cC :YcmCompleter GoToDefinition<cr>
nnoremap <space>cf :YcmCompleter FixIt<cr>
nnoremap <space>cd :YcmCompleter GetDoc<cr>
nnoremap <space>ct :YcmCompleter GetType<cr>

let g:jm_vimrc.docs.mappings["<space>T"] =
      \ 'Go to java test (and maybe make it)'
nnoremap <space>T :FindOrMakeJavaTest<cr>

let g:jm_vimrc.docs.mappings['\a[:(]'] =
      \ 'Extra/overriden EasyAlign items'
let g:easy_align_delimiters = bss#extra#EasyAlignDelimiters()

let g:jm_vimrc.docs.mappings['\[0-9]'] =
      \ 'Switch to buffer (from buftabline)'
nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)
" }}} Keymappings

" Commands: {{{
" Note -bar allows these to be followed by | to chain commands (ie. for autocmds)

" Command :Term ~ Nicer :term API
" :Term ~ Runs 'shell'
" :Term [command]... ~ Runs the command in 'shell'
"
" This command will reuse the last window, unless it's no longer being used
" for the terminal buffer. Also, this hides the buffer, in case you leave a
" terminal window running and don't want to accidentally get stuck in it.
if !exists('g:jm_term') || !exists('g:jm_terms')
  let g:jm_term = bss#view#TermView()
  let g:jm_terms = {}
endif
let g:jm_vimrc.docs.commands['Term'] =
      \ 'Run a terminal command in a reused window'
command! -nargs=* -complete=shellcmd Term
      \ eval g:jm_term.Run(<q-args>)

let g:jm_vimrc.docs.commands['TermSet'] =
      \ 'Set an option on the term window'
command! -nargs=* -complete=option TermSet
      \ eval g:jm_term.Exec(printf("setlocal %s", <q-args>))

let g:jm_vimrc.docs.commands['Terms'] =
      \ 'Run a terminal command in a reused named window. Terms [name] [cmd]...'
command! -nargs=* -complete=shellcmd Terms
      \ eval bss#SetDefault(g:jm_terms, [<f-args>][0], {-> bss#view#TermView()})
      \   .Run([<f-args>][1:]->join(' '))

let g:jm_vimrc.docs.commands['ReplaceR'] =
      \ 'Locally set \r to run :Term with the specified command'
command! -nargs=+ ReplaceR
      \ nnoremap <buffer> <localleader>r :Term <args><cr>

let g:jm_vimrc.docs.commands['ReplaceRTarget'] =
      \ 'Set \r to bazel target of the current file'
command! -bar ReplaceRTarget
      \ execute 'ReplaceR' BlazeGuessCommand()

let g:jm_vimrc.docs.commands['StopAllJobs'] =
      \ 'Stop all running jobs'
command! -bar StopAllJobs eval job_info()->map('job_stop(v:val)')

let g:jm_vimrc.docs.commands['ListAllJobs'] =
      \ 'List all running jobs'
command! -bar -bang ListAllJobs
      \ call bss#PP(job_info()->filter('<bang>0 || (job_status(v:val) == "run")'))

let g:jm_vimrc.docs.commands['DumpAllJobs'] =
      \ 'List job_infos for all running jobs'
command! -bar -bang DumpAllJobs
      \ call bss#PP(job_info()->filter('<bang>0 || (job_status(v:val) == "run")')->map('job_info(v:val)'))

let g:jm_vimrc.docs.commands['SetupClasspath'] =
      \ 'Set classpath to jm_vimrc.deps.ClasspathJarList()'
command! -bar SetupClasspath
      \ let $CLASSPATH = join(g:jm_vimrc.deps.ClasspathJarList(), ':')

let g:jm_vimrc.docs.commands['SetupTargetClasspath'] =
      \ 'Set classpath to blaze target included jars'
command! -bar SetupTargetClasspath
      \ let $CLASSPATH = s:TargetClasspath()

let g:jm_vimrc.docs.commands['SetupCV'] =
      \ 'Setup $LDFLAGS, $CFLAGS and &path for OpenCV development'
command! -bar SetupCV
      \ let $LDFLAGS = '-lopencv_core -lopencv_imgcodecs -lopencv_imgproc' |
      \ let $CFLAGS = '-I/usr/include/opencv4' |
      \ let &path ..= ',/usr/include/opencv4,/usr/include/c++/10/'

let g:jm_vimrc.docs.commands['FixHeight'] =
      \ 'Resize window and fix its height'
command! -nargs=1 FixHeight
      \ resize <args> | set winfixheight

let g:jm_vimrc.docs.commands['SetupTermRainbow'] =
      \ 'Add Rainbow-coloring to terminals'
command! -bar SetupTermRainbow
      \ autocmd TerminalOpen * RainbowLoad

let g:jm_vimrc.docs.commands['SetupAutoread'] =
      \ 'Enable autoread and add checktime autocmd'
command! -bar SetupAutoread
      \ set autoread | autocmd FocusGained,BufEnter * checktime

let g:jm_vimrc.docs.commands['RemoveTrailingWhitespace'] =
      \ 'Removes all trailing whitespace from the selected lines'
command! -range=% RemoveTrailingWhitespace
      \ <line1>,<line2>s/\s\+$//

let g:jm_vimrc.docs.commands['SetupMatchHex'] =
      \ 'Match hex numbers'
command! -bar SetupMatchHex
      \ match GruvboxAqua /\<0x0*\zs[1-9a-f]\x*\>/

let g:jm_vimrc.docs.commands['SetupMatchNum'] =
      \ 'Match decimal numbers'
command! -bar SetupMatchNum
      \ match GruvboxAqua /\<\(0x\)\?0*\zs[1-9a-f]\x*\>/

let g:jm_vimrc.docs.commands['RefreshSnippets'] =
      \ 'Refresh ultisnips'
command! -bar RefreshSnippets
      \ call UltiSnips#RefreshSnippets()

let g:jm_vimrc.docs.commands['Dis'] =
      \ 'Setup terminal for viewing objdump output ($ objdump -d ... | vim +Dis -)'
command! -bar Dis
      \ setlocal ft=dis buftype=nofile

let g:jm_vimrc.docs.commands['Center'] =
      \ 'Block alignment-preserving :center'
call bss#draw#block#RegisterCommands()

let g:jm_vimrc.docs.commands['ToggleFoldOpenSearch'] =
      \ 'Toggle search on foldopen option'
command! ToggleFoldOpenSearch
      \ if stridx(&foldopen, "search") == -1 |
      \   set foldopen+=search |
      \   echo "ENABLED foldopen search" |
      \ else |
      \   set foldopen-=search |
      \   echo "DISABLED foldopen search" |
      \ endif

let g:jm_vimrc.docs.commands['SetupMath'] =
      \ 'Set up abbreviations for math symbols'
command! SetupMath
      \ execute 'iabbrev <buffer> nn ∩' |
      \ execute 'iabbrev <buffer> uu ∪' |
      \ execute 'iabbrev <buffer> in ∈' |
      \ execute 'iabbrev <buffer> ni ∉' |
      \ execute 'iabbrev <buffer> ss ⊂' |
      \ execute 'iabbrev <buffer> se ⊆' |
      \ execute 'iabbrev <buffer> ns ⊄' |
      \ execute 'iabbrev <buffer> AN ∧' |
      \ execute 'iabbrev <buffer> OR ∨' |
      \ execute 'iabbrev <buffer> es ∅' |
      \ execute 'iabbrev <buffer> => ⇒' |
      \ execute 'iabbrev <buffer> == ⇔' |
      \ execute 'iabbrev <buffer> != ≠' |
      \ execute 'iabbrev <buffer> co ∘' |
      \ execute 'iabbrev <buffer> FA ∀' |
      \ execute 'iabbrev <buffer> TE ∃' |
      \ execute 'iabbrev <buffer> \|> ↦'

let g:jm_vimrc.docs.commands['PyHelp'] =
      \ 'Look-up help for python expression (: PyHelp <pkg> <cls>)'
command! -nargs=+ -bang PyHelp
      \ call py3eval((<bang>0) ? printf('help(%s)', <q-args>) : printf('help(__import__("%s").%s)', <f-args>))

let g:jm_vimrc.docs.commands['MakeOrSetup'] =
      \ 'Run blaze, make, or create a Makefile with included commands (using ; as separator)'
command! -nargs=+ MakeOrSetup call s:MakeOrSetup(<q-args>)
function! s:MakeOrSetup(cmds) abort
  if filereadable('WORKSPACE')
    execute 'Term blaze build' BlazeTarget()
  elseif filereadable('Makefile')
    Term make
  else
    let l:cmds = substitute(a:cmds, '%', expand('%'), 'g')
    let l:lines = split(l:cmds, ';')->map('trim(v:val)')
    let l:cursor = bss#cursor#SaveWithBuf()
    try
      redir > Makefile
      silent echo '.PHONY: all'
      silent echo 'all:'
      for l:cmd in l:lines
        silent echo '	' .. l:cmd
      endfor
      redir END
      silent edit Makefile
      Term make
    finally
      call l:cursor.Restore()
    endtry
  endif
endfunction

let g:jm_vimrc.docs.commands['SetupYcmClasspath'] =
      \ 'Create .ycm_extra_conf.py with CLASSPATH'
command! -bang SetupYcmClasspath
      \ call s:SetupYcmClasspath($CLASSPATH)
function! s:SetupYcmClasspath(classpath) abort
  let l:classpath = split(a:classpath, ':')
  let l:lines = s:GenerateYcm(l:classpath)
  if filereadable('.ycm_extra_conf.py')
    throw 'ERROR(FileExists): .ycm_extra_conf.py already exists!'
  else
    call writefile(l:lines, '.ycm_extra_conf.py')
    YcmRestartServer
  endif
endfunction
function! s:GenerateYcm(classpath) abort
  let l:path = a:classpath
        \->map('string(v:val)')
        \->join(", ")
  let l:lines =<< eval trim END
    def Settings(**kwargs):
        if kwargs["language"] == "java":
            return {{
                "ls": {{
                  "java.project.referencedLibraries": [{l:path}]
                }}
            }}
  END
  return l:lines
endfunction

let g:jm_vimrc.docs.commands['SetupOcamlformat'] =
      \ 'Create a basic .ocamlformat'
command! SetupOcamlformat call s:SetupOcamlformat()
function! s:SetupOcamlformat() abort
  if !filereadable('.ocamlformat')
    call writefile(['profile = default'], '.ocamlformat')
  endif
endfunction

" The Silver Searcher
if executable('ag')
    " Use ag over grep
    set grepprg=ag\ --nogroup\ --nocolor\ --ignore=tags\ --vimgrep
    set grepformat^=%f:%l:%c:%m
endif
" }}} Commands

" FT-Specific Settings: {{{

" Autocommands are split into filetype `augroup`s, each is separated by
" filetype. This solves the problem of sourcing the vimrc multiple times
" causing multiple duplicated autocommands to be set. An augroup is only run
" once**.
"
" These keymappings depend on the filetype, when :filetype on is enabled (as
" it is earlier in this config), when vim first loads a buffer, it will
" automatically detect the filetype and set the 'filetype' option (buffer)
" locally. After this happens, any `FileType` type autocommands are triggered
"
" NOTES:
" ** An augroup doesn't provide this functionality by itself. When you
" redefine it, it will 'add onto' the original one, in order to clear one, you
" can add `autocommand!` or `au!` to it (or another with the same name). This
" is used to make sure that only one version of the autocommand hooks is set
" per buffer.
augroup ft_latex
    autocmd!
    autocmd FileType tex setlocal nocursorline
    autocmd FileType tex setlocal tabstop=4 shiftwidth=4
    autocmd FileType tex nnoremap <buffer> <localleader>r
          \ :execute 'Term fish -c "mkt ' .. expand('%') .. '"'<cr>
augroup END

augroup ft_dot
    autocmd!
    autocmd FileType dot setlocal tabstop=2 shiftwidth=2
    autocmd FileType dot nnoremap <buffer> <localleader>r
          \ :execute 'Term dot -T svg -O' expand('%') <cr>
augroup END

augroup ft_c
    autocmd!
    autocmd FileType c setlocal tabstop=2 shiftwidth=2
    autocmd FileType c setlocal foldmethod=syntax
    autocmd FileType c nnoremap <buffer> <localleader>r
          \ :Term make<CR>
    autocmd FileType c nnoremap <buffer> <localleader>R
          \ :MakeOrSetup gcc -Wall -O3 -o a.out %; ./a.out; rm a.out<cr>
augroup END


augroup ft_cc
    autocmd!
    autocmd FileType cpp setlocal tabstop=2 shiftwidth=2
    autocmd FileType cpp setlocal foldmethod=syntax
    autocmd FileType cpp nnoremap <buffer> <localleader>t
          \ :term <C-r>=BlazeGuessCommand()<CR>
    autocmd FileType cpp nnoremap <buffer> <localleader>r
          \ :MakeOrSetup
          \   clang++-12 -std=c++17 $(CFLAGS) -o build % $(LDFLAGS);
          \   ./build<CR>
    autocmd FileType cpp nnoremap <buffer> <space>f
          \ :FormatCode<CR>
    autocmd FileType cpp
          \ if exists('g:jm_setup_cpp_cv') |
          \   SetupCV |
          \ endif
    autocmd FileType cpp
          \ if expand('%:p') =~ '/home/jmend/pg' |
          \   silent ReplaceRTarget |
          \ endif
augroup END

augroup ft_gdb
    autocmd!
    autocmd FileType gdb nnoremap <buffer> <localleader>r
          \ :execute 'Term gdb -q -x' expand('%')<cr>
augroup END

augroup ft_python
    autocmd!
    autocmd FileType python command! RunPython
          \ execute "Term" g:jm_vimrc.deps.python expand('%')
    autocmd FileType python command! RunPythonTests
          \ execute "Term" g:jm_vimrc.deps.python "-m pytest" expand('%')
    autocmd FileType python command! RunPythonTypechecks
          \ execute "Term" g:jm_vimrc.deps.python "-m mypy --ignore-missing-imports --follow-imports=skip " expand("%")
    autocmd FileType python command! RunPythonMPL
          \ StopAllJobs | eval timer_start(0, {-> execute('RunPython')})
    autocmd FileType python nnoremap <buffer> <localleader>r
          \ :RunPython<cr>
    autocmd FileType python nnoremap <buffer> <localleader>R
          \ :RunPythonTests<cr>
    autocmd FileType python nnoremap <buffer> <localleader>t
          \ :RunPythonTypechecks<cr>
    autocmd FileType python nnoremap <buffer> <space>f
          \ :FormatCode<CR>

    autocmd BufNewFile .ycm_extra_conf.py call setline('.', [
          \   'def Settings(**kwargs):',
          \   '    if kwargs["language"] == "java":',
          \   '        return {',
          \   '            "ls": {',
          \   '                "java.project.referencedLibraries": ["~/.jars/*.jar"]',
          \   '            }',
          \   '        }',
          \ ])


augroup END

augroup ft_scheme
    autocmd!
    autocmd FileType scheme setlocal colorcolumn=79
    autocmd FileType scheme let g:lisp_rainbow = v:true
    autocmd FileType scheme nnoremap <buffer> <localleader>r
          \ :w<CR> :Term mit-scheme --load % <CR>
augroup END

augroup ft_java
    autocmd!
    autocmd FileType java
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 shiftwidth=2 smarttab
    autocmd FileType java
          \ setlocal foldmethod=marker foldmarker={,}
    autocmd FileType java nnoremap <space>f :FormatCode<cr>
    autocmd FileType java nnoremap <space>F :set bt=nowrite <bar> FormatCode<cr>
    autocmd FileType java vnoremap <space>f :FormatLines<cr>
    if filereadable('Makefile')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :Term make<cr>
    elseif filereadable('WORKSPACE')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :execute "Term blaze run " .. join(<SID>BlazeTargets(expand("%")), " ")<cr>
    elseif filereadable('gradlew')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :Term ./gradlew test --rerun<cr>
    else
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :MakeOrSetup java %<cr>
    endif
    autocmd FileType java nnoremap <silent> <buffer> <localleader>R
          \ :Term ./gradlew run<cr>
    autocmd FileType java let b:surround_99 = "{@code \r}"
augroup END

augroup ft_kotlin
    autocmd!
    autocmd FileType kotlin
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 shiftwidth=2 smarttab
    if filereadable('Makefile')
      autocmd FileType kotlin nnoremap <silent> <buffer> <localleader>r
            \ :Term make<cr>
    elseif filereadable('gradlew')
      autocmd FileType kotlin nnoremap <silent> <buffer> <localleader>r
            \ :Term ./gradlew test --rerun<cr>
    else
      autocmd FileType kotlin nnoremap <silent> <buffer> <localleader>r
            \ :MakeOrSetup ./gradlew run %<cr>
    endif
    autocmd FileType kotlin nnoremap <silent> <buffer> <localleader>R
          \ :Term ./gradlew run<cr>
augroup END

augroup ft_jar
  autocmd!
  autocmd FileType jar
        \ call zip#Browse(expand("<amatch>"))
  autocmd FileType jar
        \ setlocal buflisted
augroup END

augroup ft_class
  autocmd!
  autocmd BufReadCmd *.class
        \ call bss#java#javap#Browse(expand("<amatch>"))
augroup END

augroup ft_javascript
    autocmd!
    autocmd FileType javascript
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType javascript nnoremap <buffer> <localleader>r
          \ :execute "Term node " .. expand('%')<cr>
    autocmd FileType javascript nnoremap <buffer> <localleader>R
          \ :Term webpack<CR>
    autocmd FileType javascript nnoremap <buffer> <space>f
          \ :FormatCode<CR>
augroup END

augroup ft_markdown
    autocmd!
    autocmd FileType markdown set textwidth=72 smartindent autoindent
    autocmd FileType markdown set cinwords+=:

    autocmd FileType markdown nnoremap <buffer> ]h :<c-u>call search('\v^#+ ', 'Wz')<cr>
    autocmd FileType markdown nnoremap <buffer> [h :<c-u>call search('\v^#+ ', 'bWz')<cr>
    "autocmd FileType markdown nnoremap <buffer> <leader>r
                "\ :Term pandoc %:p -s --highlight-style kate --pdf-engine=xelatex -o gen/%:t:r.pdf<cr>

    autocmd FileType markdown nnoremap <buffer> <space>l :<c-u>lvimgrep /\v^#+ / %<cr>

    autocmd FileType markdown nnoremap <buffer> <localleader>r
          \ :call bss#md#GoToRandomSection()<cr>
          \ :normal zt0<cr>

    autocmd FileType markdown command! SetupRPandoc nnoremap <buffer> <localleader>r
          \ :call execute(printf(
          \     "Term pandoc %s -s --highlight-style kate --pdf-engine=xelatex -o %s.pdf",
          \     expand('%:p'),
          \     expand('%:t:r'),
          \   ))<cr>

    autocmd FileType markdown command! JmMdQuotesAsComments match GruvboxFg3 /^\s*>.*/

    if !exists('g:bss_markdown_fix') || !g:bss_markdown_fix
      " Disable indent-based code blocks, this enables arbitrarily deep
      " indentation of lists
      autocmd FileType markdown syntax clear markdownCodeBlock
      autocmd FileType markdown syntax region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
      autocmd FileType markdown syntax region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend

      " Fix up the colors
      autocmd FileType markdown highlight link markdownH1 GruvboxRedBold
      autocmd FileType markdown highlight link markdownH2 GruvboxBlueBold
      autocmd FileType markdown highlight link markdownH3 GruvboxGreenBold
      autocmd FileType markdown highlight link markdownH4 GruvboxPurpleBold

      " Ensure bold/italics are highlighted
      autocmd FileType markdown highlight link markdownBold GruvboxFg4
      autocmd FileType markdown highlight link markdownBoldDelimiter GruvboxFg4
      autocmd FileType markdown highlight link markdownItalic GruvboxFg2
      autocmd FileType markdown highlight link markdownItalicDelimiter GruvboxFg2
    endif
augroup END

augroup ft_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker shiftwidth=2
    autocmd FileType vim nnoremap <buffer> <localleader>r
          \ :source %<cr>
    autocmd FileType vim nnoremap K :help <C-r><C-w><CR>
augroup END

augroup ft_fish
    autocmd!
    autocmd FileType fish setlocal tabstop=4 shiftwidth=4 smartindent
    autocmd FileType fish nnoremap <buffer> <space>f
          \ :0,$!fish_indent<cr>
    autocmd FileType fish setlocal omnifunc=bss#fish#Complete
augroup END

augroup ft_make
    autocmd!
    autocmd FileType make nnoremap <buffer> <localleader>r
          \ :Term make<cr>
augroup END

augroup ft_ocaml
    autocmd!
    autocmd FileType ocaml
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType ocaml nnoremap <space>f :FormatCode<cr>
    autocmd FileType ocaml vnoremap <space>f :FormatLines<cr>
    if filereadable('Makefile')
      autocmd FileType ocaml nnoremap <silent> <buffer> <localleader>r
            \ :Term make<cr>
    elseif filereadable('dune-project')
      autocmd FileType ocaml nnoremap <silent> <buffer> <localleader>r
            \ :Term dune build<cr>
    else
      autocmd FileType ocaml nnoremap <silent> <buffer> <localleader>r
            \ :execute 'Term ocaml' expand("%")<cr>
    endif
    if isdirectory('/usr/bin/ocaml')
      autocmd FileType ocaml set path+=/usr/lib/ocaml
    endif
augroup END

augroup ft_coq
    autocmd!
    autocmd FileType coq
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab smartindent
    if filereadable('Makefile')
      autocmd FileType coq nnoremap <silent> <buffer> <localleader>r
            \ :Term make<cr>
    else
      autocmd FileType coq nnoremap <silent> <buffer> <localleader>r
            \ :execute 'Term coqc' expand("%")
            \ <bar> execute 'TermSet ft=coq'<cr>
    endif
augroup END

" Use quickfix window when using :make
augroup cfg_quickfix_fix
    autocmd QuickFixCmdPost [^l]* nested cwindow
    autocmd QuickFixCmdPost    l* nested lwindow
augroup end

" }}} FT-Specific Settings

" Misc: {{{

" :FindImport {Classname}
"   Attempt to find and a Java import statement for the {Classname}
"     1. Try the `g:jm_vimrc.java_import_cache`
"     2. Search the CWD using `ag` for an `import .*\.{ClassName};`
"     3. Finally, search `g:jm_vimrc.deps.JavaClassnameList()`
"   Alternatively, for C++ do only:
"     1. Try the `g:jm_vimrc.cc_import_cache`
" {{{
let g:jm_vimrc.docs.commands['FindImport'] =
      \ 'Given a name, find the corresponding import and add an import statment'
nnoremap <space>t :call <SID>FindImport(expand('<cword>'))<CR>
command -nargs=1 FindImport call <SID>FindImport(<q-args>)
function! s:FindImport(word) abort

  if &filetype ==# 'cpp'
    let l:res = g:jm_vimrc.cc_import_cache
          \->copy()
          \->filter({incl, names -> index(names, a:word) != -1})
          \->keys()
          \->map({k, incl -> printf("#include %s", incl)})
    if len(l:res) == 0
      echo "FindImport: `" .. a:word .. "` not found!"
    elseif len(l:res) > 1
      call maktaba#ui#selector#Create(l:res)
            \.WithMappings({'<cr>': [function("s:AddImportCpp")->get("name"), 'Close', 'Add import']})
            \.Show()
    else
      call s:AddImportCpp(l:res[0])
    endif
    return
  endif

  if &filetype !=# 'java'
    throw 'ERROR(InvalidFiletype)'
    return
  endif

  " First try the g:jm_vimrc.java_import_cache
  if (has_key(g:jm_vimrc.java_import_cache, a:word))
    call s:AddOrSelectImport(get(g:jm_vimrc.java_import_cache, a:word)->mapnew({_, w -> printf('import %s;', w)}))
    return
  endif

  " Next find an import statement in the current directory
  let l:results = printf(
          \ '%s --nofilename --nobreak %s',
          \ g:jm_vimrc.deps.ag,
          \ shellescape(printf('import .+\b%s\b;', a:word)))
          \->systemlist()
          \->sort()
          \->uniq()

  " Finally, fallback to classname list
  if empty(l:results)
    let l:results = g:jm_vimrc.deps.JavaClassnameList()
          \->filter('v:val =~# a:word')
          \->map('"import " .. v:val .. ";"')
  endif

  call s:AddOrSelectImport(l:results)
endfunction

function! s:AddOrSelectImport(options) abort
  if len(a:options) == 1
    call s:AddImport(a:options[0])
  elseif len(a:options) > 1
    call maktaba#ui#selector#Create(a:options)
          \.WithMappings({'<cr>': [function("s:AddImport")->get("name"), 'Close', 'Add import']})
          \.Show()
  endif
endfunction

function! s:AddImport(import) abort
    let l:result = search(a:import, 'nw')
    if l:result == 0
      let l:start = search('^import', 'nw')
      if l:start == 0
        let l:start = search('^package', 'nw')
        call append(l:start, [""])
        let l:start += 1
      endif
      call append(l:start, [a:import])
      "execute '1,1FormatLines'
      echom "Adding: " .. a:import
    else
      echom "Already Present: " .. a:import
    endif
endfunction

function! s:AddImportCpp(import) abort
    let l:result = search(a:import, 'nw')
    if l:result == 0
      let l:start = search('^#include', 'nw')
      call append(l:start, [a:import])
      "execute '1,1FormatLines'
      echom "Adding: " .. a:import
    else
      echom "Already Present: " .. a:import
    endif
endfunction
" }}}

" :Javap {qualified-classname}
"   Run `javap` against the provided classname
" {{{
let g:jm_vimrc.docs.commands['Javap'] =
      \ 'Execute Javap and show output with highlighting'
command! -nargs=? -complete=customlist,<SID>JavapComplete -bang
        \ Javap call <SID>Javap(<q-args>, "<bang>" ==# '!')
function! s:Javap(arg, search) abort
  if empty($CLASSPATH)
    SetupClasspath
  endif

  " Note: Vim Syntax highlighting doesn't like `\->substitute(...)`
  let l:cls = empty(a:arg) ? @" : a:arg
  let l:cls = substitute(l:cls, '\(;\|<.\+>\)', '', 'ga')

  if a:search
    let l:results = s:JavapComplete(l:cls, v:none, v:none)
    if len(l:results) == 1
      let l:cls = l:results[0]
    else
      call maktaba#ui#selector#Create(l:results)
            \.WithMappings({'<cr>': [function("s:JavapOpen")->get("name"), 'Close', 'Open window']})
            \.Show()
      return
    endif
  endif

  eval g:jm_term
        \.Run(join([g:jm_vimrc.deps.javap, l:cls], ' '))
        \.Exec('set ft=java')
endfunction

function! s:JavapComplete(arg_lead, cmd_line, cursor_pos) abort
  return g:jm_vimrc.deps.JavaClassnameList()
        \->filter('v:val =~# a:arg_lead')
endfunction

function! s:JavapOpen(cls) abort
  execute 'Javap ' .. a:cls
endfunction
" }}}

" :MavenSearch {query}
" :M {query}
"   Run a maven query, and show results in a selector window
" {{{
let g:jm_vimrc.docs.commands['MavenSearch'] =
      \ 'Search maven, then either add a dependecy or download the jar'
command! -nargs=1 MavenSearch call <SID>MavenSearch(<q-args>)
command! -nargs=1 M MavenSearch <args>
function! s:MavenSearch(query) abort
  const l:request = {
        \   "page": 0,
        \   "size": 20,
        \   "searchTerm": a:query,
        \   "filter": []
        \ }
  const l:query_url =
        \ 'https://central.sonatype.com/api/internal/browse/components'

  const l:query_cmd = join([
        \   g:jm_vimrc.deps.curl,
        \   '-s',
        \   l:query_url,
        \   '--json',
        \   shellescape(json_encode(l:request))
        \ ])

  let l:msg = system(l:query_cmd)
  let l:resp = json_decode(l:msg)

  if l:resp.totalResultCount == 0
    echom "None found!"
    return
  endif
  let l:components = l:resp.components
  const l:mappings = {
        \   '<cr>': [function("s:MInsert")->get("name"), 'Close', 'Insert below'],
        \   'D': [function("s:MDownload")->get("name"), 'Close', 'Insert below'],
        \ }
  call maktaba#ui#selector#Create(map(l:components, 'v:val.namespace .. ":" .. v:val.name .. ":" ..  v:val.latestVersionInfo.version'))
        \.WithMappings(l:mappings)
        \.Show()
endfunction

function! s:MInsert(msg) abort
  let l:spaces = getline('.')->matchstr('^\s*')
  call append(line('.'), printf("%simplementation '%s'", l:spaces, a:msg))
endfunction

function! s:MDownload(msg) abort
  let [l:package, l:name, l:version] = split(a:msg, ':')
  let l:url_package = substitute(l:package, '\.', '/', 'g')
  let l:url = printf('https://repo1.maven.org/maven2/%s/%s/%s/',
        \  l:url_package,
        \  l:name,
        \  l:version)
  let l:file = printf('%s-%s.jar', l:name, l:version)
  let l:file_url = l:url .. l:file
  echom l:url .. l:file

  const l:cmd = join([
        \   g:jm_vimrc.deps.curl,
        \   '-o',
        \   shellescape(l:file),
        \   '-s',
        \   shellescape(l:file_url),
        \ ])
  silent call system(l:cmd)
  if v:shell_error
    echom 'ERROR: Could not download! ' .. l:file_url
  endif
endfunction
" }}}

" Bazel/Blaze helper functions
"
"   s:BlazeTargets({fname})
"     Return the targets that depend on {fname} directly
"
"   BlazeTarget()
"     Returns the first target for the current file
"
"   s:TargetClasspath()
"     Returns the classpath for BlazeTarget()
"
"   s:CompleteTargets({arg_lead}, {cmd_line}, {cursor_pos})
"     A -complete=customlist compatible function that simply filters the
"     commandline against all targets
"
" {{{
function! s:BlazeTargets(fname) abort
  let l:query = printf(
        \   'same_pkg_direct_rdeps(%s)',
        \   fnamemodify(a:fname, ":p:."),
        \ )

  let l:command = printf(
        \   "%s query '%s'",
        \   g:jm_vimrc.deps.blaze,
        \   l:query,
        \ )
  return filter(systemlist(l:command), 'v:val =~# "^//"')
endfunction

function! BlazeGuessCommand(show = v:false) abort
  let l:fname = expand('%:p')

  let l:target = BlazeTarget()
  if l:target ==# "???"
    echom "Can't find blaze target!"
    return "false"
  endif

  let l:action = 'build'
  if l:fname =~# '\v(_test.cc|Test.java)$' || l:target =~# '\v(_test|Test)$'
    let l:action = 'test'
  elseif l:fname =~# '\v(main.cc|_bin.cc|Bin.java)$' || l:target =~# '\v(_bin|Bin|main|Main)$'
    let l:action = 'run'
  elseif l:fname =~# '\v(_bench.cc)$' || l:target =~# '\v(_bench)$'
    let l:action = 'run -c opt'
  endif

  let l:command = printf(
        \   "%s %s %s",
        \   g:jm_vimrc.deps.blaze,
        \   l:action,
        \   l:target,
        \ )
  if a:show
    echom 'Using:' l:command
  endif
  return l:command
endfunction

function! BlazeTarget() abort
  return get(s:BlazeTargets(expand('%:p')), 0, "???")
endfunction

function! s:TargetClasspath() abort
  let l:target = BlazeTarget()
  if l:target ==# "???"
    echom "Can't find blaze target!"
    return ""
  endif

  let l:lines = systemlist(printf('blaze print_action "%s"', l:target))
  let l:jars = filter(l:lines, {_, v -> v =~# '^\s\+\(outputjar\|classpath\): "[^"]*"'})
        \->map({_, v -> matchlist(v, '"\([^"]*\)"')[1]})
  return join(l:jars, ':')
endfunction

function! s:CompleteTargets(arg_lead, cmd_line, cursor_pos) abort
  if a:arg_lead =~ '^//.*'
    return systemlist(printf('%s query ... 2>&1', g:jm_vimrc.deps.blaze))
          \->filter('v:val =~# "' .. a:arg_lead .. '"')
  endif
endfunction
" }}}

" :Touch {path}...
"   Like `$ touch`, but also create directories if necessary
" {{{
let g:jm_vimrc.docs.commands['Touch'] =
      \ 'Create files and directories'
command! -nargs=* Touch call s:Touch([<f-args>])
function! s:Touch(paths) abort
  for l:path in a:paths
    let l:dir = fnamemodify(l:path, ':h')
    if l:dir !=# '.' && !isdirectory(l:dir)
      call system('mkdir -p ' .. shellescape(l:dir))
    endif
    if !filereadable(l:path)
      call system('touch ' .. shellescape(l:path))
    endif
  endfor
endfunction
" }}}

" :CurrentHLGroup
"   Print the highlight Group under cursor
" {{{
let g:jm_vimrc.docs.commands['CurrentHLGroup'] =
      \ 'Echo name of the highlight group under the cursor'
command! CurrentHLGroup echo s:SyntaxItem()
function! s:SyntaxItem()
  return synIDattr(synID(line("."), col("."), 1), "name")
endfunction
" }}}

" AsyncExec(fn)
"   Call fn() async
"
" AsyncExec(...)
"   Join string arguments and exec async
" {{{
function! s:Async(Fn)
  eval timer_start(0, a:Fn)
endfunction

function! s:AsyncExec(...)
  eval s:Async({-> execute(join(map(a:000, function('string'))))})
endfunction
" }}}

" ConcealK
"   Define conceal rules: eg. ConcealK lambda:λ
" {{{
let g:jm_vimrc.docs.commands['ConcealK'] =
      \ 'Define conceal rules: eg. ConcealK lambda:λ'
command! -complete=expression -nargs=1 ConcealK call <SID>ConcealK(<q-args>)
function! s:ConcealK(repl_str) abort
  let l:repl = {}
  let l:i = 0
  for [l:keyword, l:replacement] in split(a:repl_str, ' ')->map('v:val->split(":")')
    let l:i += 1
    execute 'syntax keyword'
          \ printf('ConcealK%03d', l:i) l:keyword
          \ 'conceal' printf('cchar=%s', l:replacement)
  endfor
  setlocal conceallevel=1
  setlocal concealcursor=ni
endfunction
" }}}

" ReadExecute
"   Execute then read the output of that vim command
" {{{
let g:jm_vimrc.docs.commands['ReadExecute'] =
      \ 'Execute then read the output of that vim command'
command! -nargs=* -complete=command ExecuteRead eval append(line('.'), execute(<q-args>)->split("\n"))
" }}}

" Bdz
"   Run buildozer on current target (or :__pkg__ if none exists)
" {{{
let g:jm_vimrc.docs.commands['Bdz'] =
      \ 'Run buildozer on current target (or :__pkg__ if none exists)'
command! -nargs=* Bdz echom
      \ system(printf("fish -c \"buildozer '%s' %s\"",
      \   join([<f-args>], ' '),
      \   BlazeTarget() != '???' ? BlazeTarget() : ':__pkg__'
      \ ))
" }}}

" JemFormat
"   Format lines between "format:`cmd`" to "format: END"
" {{{
let g:jm_vimrc.docs.commands['JemFormat'] =
      \ 'Format lines between "format:`cmd`" to "format: END"'
command! -nargs=* -complete=customlist,<SID>JemFormatComplete JemFormat eval s:JemFormat[<q-args>]()
let s:JemFormat = {
      \   ''     : {-> s:JemFormat.format()},
      \   'help' : {-> bss#PP(s:JemFormat, v:true)},
      \ }
function! s:JemFormatComplete(arglead, cmdline, curpos) abort
  return keys(s:JemFormat)->filter({k, v -> !stridx(v, a:arglead)})
endfunction

function! s:JemFormat.format() abort dict
  let command = self.find()
  if !empty(command)
    silent execute command
  endif
endfunction

function! s:JemFormat.find() abort dict
  let [_, num, col; _] = getcurpos()
  let start_pat   = '\v.*for' .. 'mat: `([^`]+)`.*'
  let end_pat     = '\v.*for' .. 'mat: END.*'
  let start_lines = matchbufline(bufnr(), start_pat, 1, num)
  let start_line  = bss#Last(start_lines)
  let end_line    = start_line
        \->bss#Get('lnum')
        \->bss#Apply({l -> matchbufline(bufnr(), end_pat, l, '$')})
        \->bss#Apply('bss#Last')
        \->bss#Or('$')
  if start_line is v:none
    return ''
  endif
  let range   = [start_line.lnum + 1, end_line.lnum - 1]->join(',')
  let command = substitute(start_line.text, start_pat, '\1', '')
  return join([range, command], ' ')
endfunction
" }}}

" AppendMarkdownBlock <fname>
"   Append the current buffer's lines to the file <fname>.
"   Adds an empty line if the last line in <fname> is non-empty.
"
" SetupAppendMarkdownBlock <fname>
"   Setup \r nmap in the current buffer
" 
" {{{
command! -nargs=1 -complete=file SetupAppendMarkdownBlock
      \ nnoremap <buffer> \r :AppendMarkdownBlock <args><cr>
command! -nargs=1 -complete=file -range=% AppendMarkdownBlock
      \ eval AppendMarkdownBlock(<q-args>, <line1>, <line2>)
command! -nargs=1 -complete=file AppendMarkdownBlockDebug
      \ eval AppendMarkdownBlock(<q-args>, 0, '$', v:true)

function! AppendMarkdownBlock(fname, begin=0, end='$', debug=v:false) abort
  let lines = getline(a:begin, a:end)->s:Markdown_lines2codeblock()
  if !a:debug
    call s:AppendMarkdownBlock_write(a:fname, lines)
  else
    call s:AppendMarkdownBlock_dump(a:fname, lines)
  endif
endfunction

""
" Convert a list of lines to a list of codeblock lines.
"
function! s:Markdown_lines2codeblock(lines) abort
  let prefix = '```'
  let suffix = prefix
  return [prefix] + a:lines + [suffix]
endfunction


""
" Add a block to a markdown file.
"
function! s:AppendMarkdownBlock_write(fname, lines) abort
  let prefix = (readfile(a:fname)->bss#Last()->empty())
        \ ? [] : [""]
  call writefile(prefix + a:lines, a:fname, 'a')
  echom "Wrote file" a:fname
endfunction

""
" Dump debug information.
"
function! s:AppendMarkdownBlock_dump(fname, lines) abort
  " Dump debug output
  echo 'fname:' a:fname
  echo 'lines:'
  echo
  for l in a:lines
    echo '  ' .. l
  endfor
endfunction
" }}}

" SetupSlimeTarget
"   Wrapper for setting the g:slime_target
" {{{
command! -nargs=? -complete=customlist,s:SetupSlimeTarget_Complete SetupSlimeTarget call s:SetupSlimeTarget(<q-args>)
let s:SlimeTargets = [
      \   'tmux',
      \   'vimterminal',
      \ ]
function! s:SetupSlimeTarget(arg) abort
  if empty(a:arg)
    echom printf('Current slime target: %s', g:slime_target)
  else
    let g:slime_target = a:arg
  endif
endfunction
function! s:SetupSlimeTarget_Complete(arg, ...) abort
  return s:SlimeTargets->filter('stridx(v:val, a:arg) == 0')
endfunction
" }}}

function! Layout() abort
  let layout = winlayout()
  return s:InvertLayout(layout)
endfunction
function! s:InvertLayout(l, path=[]) abort
  if len(a:l) != 2
    throw "ERROR(InvalidArguments): s:InvertLayout expects only 2-element lists"
  endif
  let [kind, val] = a:l
  if kind ==# 'leaf'
    return {val: join(a:path, '')}
  elseif kind ==# 'col'
    return val
          \->map('s:InvertLayout(v:val, a:path + ["|"])')
          \->reduce({a, b -> extend(a, b)})
  elseif kind ==# 'row'
    return val
          \->map('s:InvertLayout(v:val, a:path + ["-"])')
          \->reduce({a, b -> extend(a, b)})
  endif
endfunction


" FindOrMakeJavaTest
"   Navigate to the associated Java test of the current file, creating one if
"   none exists.
" {{{
command! FindOrMakeJavaTest call s:FindOrMakeJavaTest()
function! s:FindOrMakeJavaTest() abort
  let l:path = expand('%:p:h')
  let l:name = expand('%:t:r')
  let l:extn = expand('%:t:e')
  if l:path =~# ".*/src/main/java/.*"
    let l:path = substitute(l:path, "src/main/java", "src/test/java", "")
    let l:name .= 'Test'
  elseif l:path =~# ".*/src/test/java/.*" && l:name =~# ".*Test$"
    let l:path = substitute(l:path, "src/test/java", "src/main/java", "")
    let l:name = l:name[:-5]
  elseif l:path =~# ".*/java/.*"
    let l:path = substitute(l:path, "/java/", "/javatests/", "")
    let l:name .= 'Test'
  elseif l:path =~# ".*/javatests/.*" && l:name =~# ".*Test$"
    let l:path = substitute(l:path, "/javatests/", "/java/", "")
    let l:name = l:name[:-5]
  endif
  execute 'edit' $"{l:path}/{l:name}.{l:extn}"
endfunction
" }}}

" }}} Misc

" Notes {{{
let s:Wtf = bss#wtf#Initialize()
call bss#wtf#AddDict(['mappings', 'm'], g:jm_vimrc.docs.mappings)
call bss#wtf#AddDict(['commands', 'c'], g:jm_vimrc.docs.commands)
" }}} Notes

" Defines the import cache used for Java import search, if an attempt to
" resolve the import for a key in this map, the value specified will be
" imported before trying any other method to find the import.
" TODO: Switch to a flat list
" Java Import Cache: {{{
let g:jm_vimrc.java_import_list =<< JAVA_IMPORT_LIST_END
com.google.auto.common.AnnotationMirrors
com.google.auto.common.AnnotationValues
com.google.auto.common.BasicAnnotationProcessor
com.google.auto.common.MoreElements
com.google.auto.common.MoreTypes
com.google.common.base.Stopwatch
com.google.common.collect.ImmutableList
com.google.common.collect.ImmutableMap
com.google.common.collect.ImmutableSet
com.google.common.collect.ImmutableTable
com.google.common.collect.Lists
com.google.common.collect.Streams
com.google.common.collect.Table
com.google.common.collect.Tables
com.google.common.math.Stats
com.google.common.math.StatsAccumulator
com.google.common.util.concurrent.AbstractExecutionThreadService
com.google.common.util.concurrent.AbstractFuture
com.google.common.util.concurrent.AbstractScheduledService
com.google.common.util.concurrent.AbstractTransformFuture
com.google.common.util.concurrent.FutureCallback
com.google.common.util.concurrent.Futures
com.google.common.util.concurrent.ListenableFuture
com.google.common.util.concurrent.ListenableFutureTask
com.google.common.util.concurrent.ListenableScheduledFuture
com.google.common.util.concurrent.ListenerCallQueue
com.google.common.util.concurrent.ListeningExecutorService
com.google.common.util.concurrent.ListeningScheduledExecutorService
com.google.common.util.concurrent.MoreExecutors
com.google.common.util.concurrent.SettableFuture
com.google.common.util.concurrent.Uninterruptibles
com.squareup.javapoet.ClassName
com.squareup.javapoet.CodeBlock
com.squareup.javapoet.FieldSpec
com.squareup.javapoet.JavaFile
com.squareup.javapoet.MethodSpec
com.squareup.javapoet.ParameterSpec
com.squareup.javapoet.ParameterizedTypeName
com.squareup.javapoet.TypeName
com.squareup.javapoet.TypeSpec
dagger.Binds
dagger.BindsInstance
dagger.Component
dagger.MapKey
dagger.Module
dagger.Provides
dagger.multibindings.ClassKey
dagger.multibindings.ElementsIntoSet
dagger.multibindings.IntKey
dagger.multibindings.IntoMap
dagger.multibindings.IntoSet
dagger.multibindings.LongKey
dagger.multibindings.Multibinds
dagger.multibindings.StringKey
dagger.producers.Produced
dagger.producers.Producer
dagger.producers.ProducerModule
dagger.producers.Producers
dagger.producers.Produces
dagger.producers.Production
dagger.producers.ProductionComponent
dagger.producers.ProductionScope
dagger.producers.ProductionSubcomponent
dagger.producers.monitoring.ProducerMonitor
dagger.producers.monitoring.ProducerToken
dagger.producers.monitoring.ProductionComponentMonitor
java.io.IOException
java.lang.reflect.AnnotatedElement
java.lang.reflect.Executable
java.lang.reflect.Field
java.lang.reflect.GenericDeclaration
java.lang.reflect.Method
java.lang.reflect.Modifier
java.lang.reflect.Type
java.nio.file.Files
java.nio.file.Path
java.util.ArrayList
java.util.Arrays
java.util.Collection
java.util.HashMap
java.util.HashSet
java.util.Iterator
java.util.LinkedList
java.util.List
java.util.Map
java.util.NavigableMap
java.util.Optional
java.util.OrderedMap
java.util.Set
java.util.TreeMap
java.util.TreeSet
java.util.concurrent.ConcurrentHashMap
java.util.concurrent.CopyOnWriteArrayList
java.util.concurrent.ExecutionException
java.util.concurrent.Executor
java.util.concurrent.ExecutorService
java.util.concurrent.Executors
java.util.concurrent.Future
java.util.concurrent.ThreadPoolExecutor
java.util.concurrent.TimeUnit
java.util.concurrent.atomic.AtomicInteger
java.util.concurrent.atomic.AtomicLong
java.util.concurrent.atomic.LongAdder
java.util.function.Consumer
java.util.function.Function
java.util.function.Predicate
java.util.function.Supplier
java.util.stream.Collector
java.util.stream.Collectors
java.util.stream.Stream
javax.annotation.processing.AbstractProcessor
javax.annotation.processing.Completion
javax.annotation.processing.Completions
javax.annotation.processing.Filer
javax.annotation.processing.FilerException
javax.annotation.processing.Generated
javax.annotation.processing.Messager
javax.annotation.processing.ProcessingEnvironment
javax.annotation.processing.Processor
javax.annotation.processing.RoundEnvironment
javax.annotation.processing.SupportedAnnotationTypes
javax.annotation.processing.SupportedOptions
javax.annotation.processing.SupportedSourceVersion
javax.inject.Inject
javax.inject.Named
javax.inject.Provider
javax.inject.Qualifier
javax.inject.Singleton
javax.lang.model.element.Element
javax.lang.model.element.ElementVisitor
javax.lang.model.element.ExecutableElement
javax.lang.model.element.Modifier
javax.lang.model.element.TypeElement
javax.lang.model.type.TypeMirror
org.apache.commons.lang3.builder.ReflectionToStringBuilder
org.apache.commons.lang3.builder.ToStringStyle
org.objectweb.asm.ClassReader
org.objectweb.asm.ClassVisitor
org.objectweb.asm.ClassWriter
org.objectweb.asm.FieldVisitor
org.objectweb.asm.MethodVisitor
org.objectweb.asm.Opcodes
org.objectweb.asm.TypePath
org.openjdk.jmh.annotations.AuxCounters
org.openjdk.jmh.annotations.Benchmark
org.openjdk.jmh.annotations.BenchmarkMode
org.openjdk.jmh.annotations.CompilerControl
org.openjdk.jmh.annotations.Fork
org.openjdk.jmh.annotations.Group
org.openjdk.jmh.annotations.GroupThreads
org.openjdk.jmh.annotations.Level
org.openjdk.jmh.annotations.Measurement
org.openjdk.jmh.annotations.Mode
org.openjdk.jmh.annotations.OperationsPerInvocation
org.openjdk.jmh.annotations.OutputTimeUnit
org.openjdk.jmh.annotations.Param
org.openjdk.jmh.annotations.Scope
org.openjdk.jmh.annotations.Setup
org.openjdk.jmh.annotations.State
org.openjdk.jmh.annotations.TearDown
org.openjdk.jmh.annotations.Threads
org.openjdk.jmh.annotations.Timeout
org.openjdk.jmh.annotations.Warmup
org.openjdk.jmh.infra.BenchmarkParams
org.openjdk.jmh.infra.Blackhole
org.openjdk.jmh.infra.Control
org.openjdk.jmh.infra.IterationParams
org.openjdk.jmh.infra.ThreadParams
org.openjdk.jmh.results.RunResult
org.openjdk.jmh.results.format.ResultFormatType
org.openjdk.jmh.runner.Runner
org.openjdk.jmh.runner.RunnerException
org.openjdk.jmh.runner.options.CommandLineOptionException
org.openjdk.jmh.runner.options.CommandLineOptions
org.openjdk.jmh.runner.options.Options
org.openjdk.jmh.runner.options.OptionsBuilder
static com.google.common.collect.ImmutableList.toImmutableList
static com.google.common.collect.ImmutableSet.toImmutableSet
static com.google.common.truth.Truth.assertThat
static com.google.common.truth.Truth.assertWithMessage
static com.google.common.util.concurrent.MoreExecutors.directExecutor
static java.util.concurrent.TimeUnit.DAYS
static java.util.concurrent.TimeUnit.HOURS
static java.util.concurrent.TimeUnit.MICROSECONDS
static java.util.concurrent.TimeUnit.MILLISECONDS
static java.util.concurrent.TimeUnit.MINUTES
static java.util.concurrent.TimeUnit.NANOSECONDS
static java.util.concurrent.TimeUnit.SECONDS
static java.util.stream.Collectors.averagingDouble
static java.util.stream.Collectors.averagingInt
static java.util.stream.Collectors.averagingLong
static java.util.stream.Collectors.collectingAndThen
static java.util.stream.Collectors.counting
static java.util.stream.Collectors.filtering
static java.util.stream.Collectors.flatMapping
static java.util.stream.Collectors.groupingBy
static java.util.stream.Collectors.joining
static java.util.stream.Collectors.mapping
static java.util.stream.Collectors.maxBy
static java.util.stream.Collectors.minBy
static java.util.stream.Collectors.partitioningBy
static java.util.stream.Collectors.reducing
static java.util.stream.Collectors.summarizingDouble
static java.util.stream.Collectors.summarizingInt
static java.util.stream.Collectors.summarizingLong
static java.util.stream.Collectors.summingDouble
static java.util.stream.Collectors.summingInt
static java.util.stream.Collectors.summingLong
static java.util.stream.Collectors.toCollection
static java.util.stream.Collectors.toConcurrentMap
static java.util.stream.Collectors.toList
static java.util.stream.Collectors.toMap
static java.util.stream.Collectors.toSet
static java.util.stream.Collectors.toUnmodifiableList
static java.util.stream.Collectors.toUnmodifiableMap
static java.util.stream.Collectors.toUnmodifiableSet
java.net.ServerSocket
java.net.Socket
java.io.OutputStream
com.google.common.flogger.FluentLogger
static com.google.common.util.concurrent.Futures.immediateFuture
java.util.concurrent.atomic.AtomicReference
static com.google.common.util.concurrent.Futures.immediateVoidFuture
java.util.concurrent.atomic.AtomicMarkableReference
java.util.Random
java.time.Instant
static com.google.common.base.Preconditions.checkArgument
static com.google.common.base.Preconditions.checkNotNull
static org.mockito.Mockito.mock
static org.mockito.Mockito.verify
static org.mockito.ArgumentMatchers.any
static org.mockito.Mockito.times
static org.mockito.AdditionalMatchers.and
static org.mockito.ArgumentMatchers.assertArg
JAVA_IMPORT_LIST_END

command! AddJavaImport call AddJavaImport(getline('.'))
function! AddJavaImport(content) abort
  let content = a:content
        \->substitute('^import ', '', '')
        \->substitute(';$', '', '')
  if index(g:jm_vimrc.java_import_list, content) != -1
    echom "Already present:" content
    return
  endif
  let lines = readfile($MYVIMRC)
  let index = match(lines, '^JAVA_IMPORT_LIST_END$')
  call insert(lines, content, index)
  call writefile(lines, $MYVIMRC)
  echom "Added:" content
endfunction

function! s:ProcessJavaImportList(import_list) abort
  let cache = {}
  for elem in a:import_list
    let name = slice(elem, strridx(elem, '.') + 1)
    if has_key(cache, name)
      call add(cache[name], elem)
    else
      let cache[name] = [elem]
    endif
  endfor
  return cache
endfunction

let g:jm_vimrc.java_import_cache =
      \ s:ProcessJavaImportList(g:jm_vimrc.java_import_list)

" }}} Java Import Cache


" C++ Import Cache: {{{
let g:jm_vimrc.cc_import_cache = {
      \   '"absl/flags/flag.h"': ['ABSL_FLAG', 'GetFlag'],
      \   '"absl/flags/declare.h"': ['ABSL_DECLARE_FLAG'],
      \   '"absl/flags/parse.h"': ['ParseCommandLine'],
      \   '"absl/flags/usage.h"': ['ProgramUsageMessage', 'SetProgramUsageMessage'],
      \   '"absl/strings/str_join.h"': ['StrJoin'],
      \   '"absl/strings/str_cat.h"': ['StrCat'],
      \   '"absl/strings/str_replace.h"': ['StrReplaceAll'],
      \   '"absl/strings/str_split.h"': ['StrSplit'],
      \   '"absl/status/status.h"': ['Status'],
      \   '"absl/status/statusor.h"': ['StatusOr'],
      \   '<opencv2/core.hpp>': [
      \     'Mat',
      \     'Mat_',
      \     'Mat1b', 'Mat2b', 'Mat3b', 'Mat4b',
      \     'Mat1i', 'Mat2i', 'Mat3i', 'Mat4i',
      \     'Mat1f', 'Mat2f', 'Mat3f', 'Mat4f',
      \     'Mat1d', 'Mat2d', 'Mat3d', 'Mat4d',
      \     'Matx',
      \     'Matx22f', 'Matx33f', 'Matx44f',
      \     'Matx21f', 'Matx31f', 'Matx41f',
      \     'Matx22d', 'Matx33d', 'Matx44d',
      \     'Matx21d', 'Matx31d', 'Matx41d',
      \     'Vec',
      \     'Vec1b', 'Vec2b', 'Vec3b', 'Vec4b', 'Vec6b',
      \     'Vec1i', 'Vec2i', 'Vec3i', 'Vec4i', 'Vec6i',
      \     'Vec1f', 'Vec2f', 'Vec3f', 'Vec4f', 'Vec6f',
      \     'Vec1d', 'Vec2d', 'Vec3d', 'Vec4d', 'Vec6d',
      \     'Scalar_', 'Scalar',
      \     'Point_', 'Point2i', 'Point2l', 'Point2f', 'Point2d',
      \     'Point3_', 'Point3i', 'Point3l', 'Point3f', 'Point3d',
      \     'abs',
      \     'exp', 'log',
      \     'pow', 'sqrt',
      \   ],
      \   '<opencv2/imgcodecs.hpp>': ['imread', 'imwrite'],
      \   '<opencv2/imgproc.hpp>': ['circle'],
      \   '<utility>': [
      \     'forward', 'declval',
      \     'move', 'swap', 'exchange',
      \     'integer_sequence', 'make_integer_sequence',
      \     'index_sequence', 'make_index_sequence',
      \     'pair', 'make_pair',
      \   ],
      \   '<memory>': ['unique_ptr', 'make_unique'],
      \   '<vector>': ['vector'],
      \   '<tuple>': [
      \     'tuple',
      \     'tuple_size',
      \     'tuple_element',
      \     'get',
      \   ],
      \   '<type_traits>': [
      \     'enable_if', 'conditional',
      \     'enable_if_t', 'conditional_t',
      \     'integral_constant', 'bool_constant',
      \     'true_type', 'false_type',
      \     'conjunction', 'disjunction', 'negation',
      \     'conjunction_v', 'disjunction_v', 'negation_v',
      \     'is_same', 'is_base_of', 'is_convertible',
      \     'is_same_v', 'is_base_of_v', 'is_convertible_v',
      \   ],
      \   '<array>': ['array'],
      \   '<valarray>': ['valarray'],
      \   '<cstddef>': [
      \     'size_t', 'ptrdiff_t', 'nullptr_t',
      \   ],
      \   '<future>': [
      \     'future', 'promise', 'async', 'launch',
      \   ],
      \   '<thread>': [
      \     'thread', 'this_thread', 'yield', 'get_id', 'sleep_for',
      \   ],
      \   '<cstdint>': [
      \     'int8_t', 'int16_t', 'int32_t', 'int64_t',
      \     'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
      \   ],
      \   '<cmath>': [
      \     'abs',
      \     'exp', 'log', 'log2', 'log10',
      \     'pow', 'sqrt', 'hypot',
      \     'sin', 'cos', 'tan',
      \     'asin', 'acos', 'atan',
      \     'sinh', 'cosh', 'tanh',
      \     'asinh', 'acosh', 'atanh',
      \     'ceil', 'floor', 'trunc', 'round',
      \   ],
      \   '<string>': [
      \     'string',
      \     'to_string',
      \     'stoi', 'stol', 'stoul', 'stoll', 'stoull',
      \     'stof', 'stod', 'stold',
      \   ],
      \   '<map>': ['map'],
      \   '<unordered_map>': ['unordered_map'],
      \   '<set>': ['set'],
      \   '<iostream>': [
      \     'cout', 'cin', 'cerr',
      \     'endl',
      \   ],
      \   '<ios>': [
      \     'internal', 'left', 'right',
      \     'boolalpha', 'showbase', 'showpos',
      \     'dec', 'hex', 'oct',
      \     'fixed', 'scientific', 'default',
      \   ],
      \   '<format>': ['format'],
      \   '<iomanip>': [
      \     'setw',
      \     'quoted',
      \   ],
      \   '<unordered_set>': ['unordered_set'],
      \   '<optional>': ['optional'],
      \   '<complex>': ['complex'],
      \   '<initializer_list>': ['initializer_list'],
      \   '<numeric>': [
      \     'iota',
      \     'accumulate',
      \     'reduce',
      \     'inner_product',
      \     'adjacent_difference',
      \     'partial_sum',
      \   ],
      \   '<cstdlib>': [
      \     'system',
      \     'exit',
      \     'getenv',
      \     'malloc',
      \     'free',
      \     'aligned_malloc',
      \   ],
      \   '<random>': [
      \     'random_device',
      \     'mt19937',
      \     'mt19937_64',
      \     'uniform_real_distribution',
      \     'uniform_int_distribution',
      \     'normal_distribution',
      \   ],
      \   '<functional>': [
      \     'function',
      \     'plus', 'minus', 'multiplies', 'divides',
      \     'equal_to', 'not_equal_to',
      \     'greater', 'less', 'greater_equal', 'less_equal',
      \     'logical_and', 'logical_or', 'logical_not',
      \     'bit_end', 'bit_or', 'bit_xor', 'bit_not',
      \   ],
      \   '<algorithm>': [
      \
      \     'all_of', 'any_of', 'none_of',
      \     'for_each', 'for_each_n',
      \     'count', 'count_if',
      \     'mismatch',
      \     'find', 'find_if', 'find_if_not',
      \     'find_end', 'find_first_of', 'adjacent_find',
      \     'search', 'search_n',
      \
      \     'copy', 'copy_backward', 'move', 'move_backward', 'copy_n',
      \     'fill', 'fill_n', 'transform', 'generate', 'generate_n',
      \     'remove', 'remove_if', 'remove_copy', 'remove_copy_if',
      \     'replace', 'replace_if', 'replace_copy', 'replace_copy_if',
      \     'swap', 'swap_ranges', 'swap_iter',
      \     'reverse', 'reverse_copy', 'rotate',
      \     'rotate_copy',
      \     'shuffle',
      \     'max', 'min', 'max_element', 'min_element', 'minmax',
      \   ],
      \   '"absl/algorithm/container.h"': [
      \
      \     'c_all_of', 'c_any_of', 'c_none_of',
      \     'c_for_each', 'c_for_each_n',
      \     'c_count', 'c_count_if',
      \     'c_mismatch',
      \     'c_find', 'c_find_if', 'c_find_if_not',
      \     'c_find_end', 'c_find_first_of', 'c_adjacent_find',
      \     'c_search', 'c_search_n',
      \
      \     'c_copy', 'c_copy_backward', 'c_move', 'c_move_backward', 'c_copy_n',
      \     'c_fill', 'c_fill_n', 'c_transform', 'c_generate', 'c_generate_n',
      \     'c_remove', 'c_remove_if', 'c_remove_copy', 'c_remove_copy_if',
      \     'c_replace', 'c_replace_if', 'c_replace_copy', 'c_replace_copy_if',
      \     'c_swap', 'c_swap_ranges', 'c_swap_iter',
      \     'c_reverse', 'c_reverse_copy', 'c_rotate',
      \     'c_rotate_copy',
      \     'c_shuffle',
      \   ],
      \   '<iterator>': [
      \     'istream_iterator',
      \     'ostream_iterator',
      \   ],
      \ }
" }}} C++ Import Cache
