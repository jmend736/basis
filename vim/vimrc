" Copyright (c) 2024 Julian Mendoza
"
" MIT License
"
" Permission is hereby granted, free of charge, to any person obtaining a copy
" of this software and associated documentation files (the "Software"), to deal
" in the Software without restriction, including without limitation the rights
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
" copies of the Software, and to permit persons to whom the Software is
" furnished to do so, subject to the following conditions:
"
" The above copyright notice and this permission notice shall be included in all
" copies or substantial portions of the Software.
"
" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
" SOFTWARE.

""
" jmend's vimrc!
"
" Self Link: jmend.io/vimrc
"
" Installing Required Plugins:
"   1. Install vim-plug: https://github.com/junegunn/vim-plug
"   2. Run :PlugInstall
"   3. Restart vim
"
" Self-Documentation:
"   :Wtf commands ~ Show commands set in this vimrc
"   :Wtf mappings ~ Show mappings set in this vimrc
"   :Wtf <tab>    ~ Show other documentation available
"                   (Mostly misc. stuff I find useful to remember)

" Required here for vim9+
set nocompatible

" Command Prefix:
"   <leader>      : used for global mappings
"   <localleader> : used for buffer-local mappings
let mapleader = '\'
let maplocalleader = '\'

" System Dependencies: {{{
let g:jm_vimrc = {}

" Will store documentation
" Accessible with the :Wtf command
let g:jm_vimrc.docs = {}

" Map from defined commands to description
" See :Wtf commands
let g:jm_vimrc.docs.commands = {}

" Map from defined mappings to description
" See :Wtf mappings
let g:jm_vimrc.docs.mappings = {}

" A variety of dependencies on the system
let g:jm_vimrc.deps = #{
      \   jshell: 'jshell',
      \   curl:   'curl',
      \   blaze:  'blaze',
      \   javap:  'javap',
      \   ag:     'ag',
      \   fish:   'fish',
      \   python: 'python3',
      \ }

" Whether this computer is a mac
let g:jm_vimrc.is_mac = system('uname -s') =~# 'Darwin'

" Whether python is supported
let g:jm_vimrc.has_python = has('python3')

" Some system dependencies
let g:jm_vimrc.deps.JavaClassnameList      = {-> systemlist('fish -c "classpath list-all-classes"')}
let g:jm_vimrc.deps.ClasspathJarList       = {-> systemlist('fish -c "jars list"')}
let g:jm_vimrc.deps.google_java_executable = 'google-java-format --skip-javadoc-formatting'
let g:jm_vimrc.deps.buildozer   = 'fish -c buildozer'
" }}}

" Playground: {{{
let s:pg_items = (g:jm_vimrc.is_mac)
      \ ? #{
      \     co: 'Files ~/Playground',
      \     cj: 'Files ~/Playground/jdk/src/java.base/share/classes',
      \     pg: 'Files ~/Playground',
      \     n:  'Files ~/Playground/jmendio/n',
      \     v:  'edit ~/.vimrc',
      \   }
      \ : #{
      \     a:  'Files ~/code/abseil-cpp/absl',
      \     co: 'Files ~/code',
      \     cg: 'Files ~/code/guava/guava/src',
      \     cj: 'Files ~/code/jdk/src/java.base/share/classes',
      \     cv: 'Files ~/code/opencv/modules/core',
      \     n:  'Files ~/jmendio/n',
      \     v:  'edit ~/.vimrc',
      \   }
for [key, path] in items(s:pg_items)
  execute printf('nnoremap <leader>e%s :%s<cr>', key, path)
  let g:jm_vimrc.docs.mappings['\e' .. key] = 'Run :' .. path
endfor
" }}} Playground

" Plugins (vim-plug): {{{
call plug#begin('~/.vim/bundle')

"" Plugins:
Plug 'morhetz/gruvbox'
Plug 'tpope/vim-surround'
Plug 'scrooloose/nerdtree'
Plug 'godlygeek/tabular'
if g:jm_vimrc.has_python
  Plug 'SirVer/ultisnips'
  Plug 'Valloric/YouCompleteMe'
endif
Plug 'honza/vim-snippets'
Plug 'junegunn/fzf', {'do': {-> fzf#install()}}
Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-fugitive'
Plug 'moll/vim-bbye'
Plug 'scrooloose/nerdcommenter' " \c<Space> \cc
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-repeat'
Plug 'triglav/vim-visual-increment'
Plug 'tmhedberg/SimpylFold'
Plug 'majutsushi/tagbar'
Plug 'pangloss/vim-javascript'
Plug 'nelstrom/vim-markdown-folding'
Plug 'justinmk/vim-syntax-extra'
Plug 'jpalardy/vim-slime'
Plug 'itchyny/lightline.vim'
Plug 'ap/vim-buftabline'
Plug 'airblade/vim-gitgutter'
Plug 'google/vim-maktaba'
Plug 'google/vim-codefmt'
Plug 'google/vim-glaive'
Plug 'frazrepo/vim-rainbow'
Plug 'AndrewRadev/splitjoin.vim' " gS gJ
Plug 'shiracamus/vim-syntax-x86-objdump-d'
Plug 'romainl/vim-devdocs'
if exists("$BASIS")
  Plug $BASIS, { 'rtp': 'vim' }
else
  Plug 'jmend736/basis', { 'rtp': 'vim' }
endif

"" Old Plugins:
" Plug 'vim-scripts/DrawIt'
" Plug 'cohama/lexima.vim'
" Plug 'mattn/emmet-vim'
" Plug 'sheerun/vim-polyglot'
" Plug 'fatih/vim-go'
" Plug 'davidhalter/jedi-vim'
" Plug 'ervandew/supertab'
" Plug 'w0rp/ale'
" Plug 'neoclide/coc.nvim', {'branch': 'release'}
" http://eclim.org
" Plug 'bazelbuild/vim-ft-bzl'
" -> https://github.com/bazelbuild/vim-ft-bzl/commit/941fb142f604c254029c2a0852ea7578f08de91a

"" Plugins to check out:
" Plug 'liuchengxu/vista.vim'
" Plug 'natebosch/vim-lsc'
" Plug 'chrisbra/NrrwRgn'
" Plug 'justinmk/vim-sneak'
" Plug 'romainl/vim-qf'
" Plug 'romainl/vim-qlist'
" Plug 'mbbill/undotree'
" Plug 'wellle/targets.vim'
call plug#end()

if !exists('g:loaded_plug')
  echoerr "ERROR: vim-plug is REQUIRED https://github.com/junegunn/vim-plug"
  finish
endif


call glaive#Install()

Glaive codefmt
      \ google_java_executable=`g:jm_vimrc.deps.google_java_executable`
      \ clang_format_style='Google'

" }}} Plugins (Vundle)

" General Options: {{{
filetype plugin indent on

set t_Co=256        " Number of colors
set t_ut=           " Use current background color for clearing

set scrolloff=0     " Minimal number of screen lines to keep above/below cursor

set shell=/bin/bash " Sets the shell to use

set hidden          " Whether to allow modified buffers to be hidden

set tabstop=2       " Number of spaces that a read <Tab> counts for
set softtabstop=2   " Number of spaces an inserted <Tab> counts for
set shiftwidth=2    " Sets what >> and << ops do
set expandtab       " Replace tabs with spaces when editing
set smarttab        " More reasonable tab actions

                    " Reasonable backspace functionality
set backspace=indent,eol,start

set list            " Replace certain characters visually
set listchars=tab:\>\ ,trail:·,extends:→,precedes:←

set number           " Show line number at cursor,
set numberwidth=4    " with a column width of 3,
set relativenumber   " and numbers relative to cursor elsewhere
set noruler          " Show line/col number (hidden by lightline)
set showcmd          " Show currently entered command below status
                     " Define status line (hidden by lightline)
set statusline=%f\ %=L:%l/%L\ %c\ (%p%%)

set wildmenu         " Tab completion for : command
set wildmode=longest,list,full

set hlsearch         " Highlight search results
set incsearch        " Highlight while searching
set foldopen-=search " Whether to open folds when searching
                     " Also see :ToggleFoldOpenSearch

" Ignore case, unless you use uppercase characters
set ignorecase
set smartcase

" Other
set fileencodings=utf-8
set tags=tags
set tags+=/usr/include/**/tags
set printoptions=number:y,duplex:long,paper:letter
if g:jm_vimrc.is_mac
  set clipboard=unnamed
else
  set clipboard=unnamedplus
endif
set errorbells
set laststatus=2
set cursorline
set sessionoptions=
      \blank,
      \curdir,
      \folds,
      \help,
      \localoptions,
      \options,
      \tabpages,
      \winsize,
      \terminal

set directory=~/.swaps//

" Themes
colorscheme gruvbox
syntax enable
set bg=dark
" }}} General Settings

" Plugin Settings: {{{

let g:lightline = {
      \   'active': {
      \     'left': [['mode', 'paste'], ['filename', 'modified']],
      \     'right': [['winid_bufnr', 'lineinfo'], ['percent', 'foldlevel'], ['readonly']]
      \   },
      \   'inactive': {
      \     'left': [['filename', 'modified']],
      \     'right': [['winid_bufnr', 'lineinfo'], ['readonly']]
      \   },
      \   'component_type': {
      \     'readonly': 'error',
      \   },
      \   'component': {
      \     'winid_bufnr': '[%{winnr()}/%{win_getid()}]{%{bufnr()}}',
      \     'foldlevel': '%{(&foldenable) ? &foldlevel : "-"}f',
      \   },
      \ }

let $FZF_DEFAULT_COMMAND = 'ag -g ""'

"let g:lsc_server_commands = {}
"let g:lsc_enable_autocomplete = v:true
"let g:lsc_auto_map = v:true

let g:ycm_auto_trigger = 1
let g:ycm_disable_signature_help = 1
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']

let g:slime_target = "tmux"

" Will disable indent-based markdown code blocks
let g:bss_markdown_fix = 1

let g:bss_java_fix = 1

let g:vim_markdown_new_list_item_indent = 0
let g:vim_markdown_folding_disabled = 1
let g:markdown_fold_style = 'nested'

let g:NERDCompactSexyComs = v:true
let g:NERDCommentEmptyLines = v:true
let g:NERDDefaultAlign = 'left'

let g:tagbar_sort = v:false

" Use ordinal numbers (2) rather than bufnum (1)
let g:buftabline_numbers = 2
let g:buftabline_indicators = v:true
let g:buftabline_separators = v:false

let g:netre_liststyle=3

let g:tex_flavor='latex'

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
let g:UltiSnipsEditSplit="vertical"

let g:gitgutter_sign_added = '··'
let g:gitgutter_sign_modified = '··'
let g:gitgutter_sign_removed = '·'
let g:gitgutter_sign_modified_removed = '·'
" }}} Plugin Settings

" Keymappings: {{{
"   To understand keys see :h key-notation

" Moves around a line more closely to what is expected (at least by me) when
" the line is wrapped.
"nnoremap j gj
"nnoremap k gk
"vnoremap j gj
"vnoremap k gk

" Moving around between windows quickly
let g:jm_vimrc.docs.mappings['<C-[hjkl]>'] =
      \ 'Move between windows by holding CTRL'
noremap <C-j> <C-W>j
noremap <C-k> <C-W>k
noremap <C-h> <C-W>h
noremap <C-l> <C-W>l

let g:jm_vimrc.docs.mappings['[['] =
      \ 'Enable [[,][,]],[] to operate on non-col-1-{}'
" From :h object-motions
nnoremap [[ ?{<CR>w99[{
nnoremap ][ /}<CR>b99]}
nnoremap ]] j0[[%/{<CR>
nnoremap [] k$][%?}<CR>

let g:jm_vimrc.docs.mappings['\q'] =
      \ 'Delete current buffer without changing window layout'
nnoremap <leader>q :Bdelete<cr>

let g:jm_vimrc.docs.mappings["\\'"] =
      \ 'Open NERDTree (file explorer)'
nnoremap <leader>' :NERDTreeToggle<cr>

let g:jm_vimrc.docs.mappings['\"'] =
      \ 'Open NERDTree (file explorer) to current file'
nnoremap <leader>" :NERDTreeFind<cr>

let g:jm_vimrc.docs.mappings['\<Tab>'] =
      \ 'Open Tagbar'
nnoremap <leader><tab> :TagbarToggle<cr>

let g:jm_vimrc.docs.mappings['<C-r><C-f>'] =
      \ '[modes:ic] Insert file name root'
inoremap <C-r><C-f> <C-r>=expand('%:p:t:r')<cr>
cnoremap <C-r><C-f> <C-r>=expand('%:p:t:r')<cr>

let g:jm_vimrc.docs.mappings['<C-r><C-t>'] =
      \ '[modes:ic] Insert file name root'
inoremap <C-r><C-t> <C-r>=BlazeTarget()<cr>
cnoremap <C-r><C-t> <C-r>=BlazeTarget()<cr>

let g:jm_vimrc.docs.mappings['<C-p>'] =
      \ 'Fuzzy-search PWD'
nnoremap <C-p> :Files<cr>

let g:jm_vimrc.docs.mappings['\w'] =
      \ 'Clear search highlights (:nohlsearch)'
nnoremap <silent> <leader>w :nohlsearch<Bar>:echo<cr>

let g:jm_vimrc.docs.mappings['<F11>'] =
      \ 'Ensure non-syntax toplevel text is spell-checked'
noremap <F11> :syntax spell toplevel<cr>
let g:jm_vimrc.docs.mappings['<F12>'] =
      \ 'Toggle spell checking'
noremap <F12> :setlocal spell! spelllang=en_us<cr>

let g:jm_vimrc.docs.mappings['<Space>l'] =
      \ 'Open Git ("Change [L]ist")'
nnoremap <leader>l :Git<cr>

let g:jm_vimrc.docs.mappings['<C-w><C-z>'] =
      \ 'Set window height to 10 and fix the height'
nnoremap <C-w><C-z> :FixHeight 10<cr>
nnoremap <C-w>z :FixHeight 10<cr>

let g:jm_vimrc.docs.mappings['K'] =
      \ 'Do grep for word under cursor'
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

let g:jm_vimrc.docs.mappings['\\'] =
      \ 'Show :tags'
nnoremap <leader><leader> :tags<cr>

let g:jm_vimrc.docs.mappings['\s'] =
      \ 'Refresh UltSnips snippets'
nnoremap <leader>s :call UltiSnips#RefreshSnippets()<cr>

let g:jm_vimrc.docs.mappings['\<Space>'] =
      \ 'Toggle foldcolumn'
nnoremap <leader><space> :let &l:foldcolumn = (&l:foldcolumn) ? 0 : 3<cr>

let g:jm_vimrc.docs.mappings['\a'] =
      \ 'Trigger EasyAlign (See :Wtf ea)'
xmap <leader>a <Plug>(EasyAlign)
nmap <leader>a <Plug>(EasyAlign)

let g:jm_vimrc.docs.mappings['\a[:(]'] =
      \ 'Extra/overriden EasyAlign items'
let g:easy_align_delimiters = bss#extra#EasyAlignDelimiters()

let g:jm_vimrc.docs.mappings['\[0-9]'] =
      \ 'Switch to buffer (from buftabline)'
nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)
" }}} Keymappings

" Commands: {{{
" Note -bar allows these to be followed by | to chain commands (ie. for autocmds)

" Command :Term ~ Nicer :term API
" :Term ~ Runs 'shell'
" :Term [command]... ~ Runs the command in 'shell'
"
" This command will reuse the last window, unless it's no longer being used
" for the terminal buffer. Also, this hides the buffer, in case you leave a
" terminal window running and don't want to accidentally get stuck in it.
if !exists('g:jm_term')
  let g:jm_term = bss#view#TermView()
endif
let g:jm_vimrc.docs.commands['Term'] =
      \ 'Run a terminal command in a reused window'
command! -nargs=* -complete=shellcmd Term
      \ eval g:jm_term.Run(<q-args>)

let g:jm_vimrc.docs.commands['ReplaceR'] =
      \ 'Locally set \r to run :Term with the specified command'
command! -nargs=+ ReplaceR
      \ nnoremap <buffer> <localleader>r :Term <args><cr>

let g:jm_vimrc.docs.commands['ReplaceRTarget'] =
      \ 'Set \r to bazel target of the current file'
command! -bar ReplaceRTarget
      \ execute 'ReplaceR' BlazeGuessCommand()

let g:jm_vimrc.docs.commands['StopAllJobs'] =
      \ 'Stop all running jobs'
command! -bar StopAllJobs eval job_info()->map('job_stop(v:val)')

let g:jm_vimrc.docs.commands['SetupClasspath'] =
      \ 'Set classpath to jm_vimrc.deps.ClasspathJarList()'
command! -bar SetupClasspath
      \ let $CLASSPATH = join(g:jm_vimrc.deps.ClasspathJarList(), ':')

let g:jm_vimrc.docs.commands['SetupTargetClasspath'] =
      \ 'Set classpath to blaze target included jars'
command! -bar SetupTargetClasspath
      \ let $CLASSPATH = s:TargetClasspath()

let g:jm_vimrc.docs.commands['SetupCV'] =
      \ 'Setup $LDFLAGS, $CFLAGS and &path for OpenCV development'
command! -bar SetupCV
      \ let $LDFLAGS = '-lopencv_core -lopencv_imgcodecs -lopencv_imgproc' |
      \ let $CFLAGS = '-I/usr/include/opencv4' |
      \ let &path ..= ',/usr/include/opencv4,/usr/include/c++/10/'

let g:jm_vimrc.docs.commands['FixHeight'] =
      \ 'Resize window and fix its height'
command! -nargs=1 FixHeight
      \ resize <args> | set winfixheight

let g:jm_vimrc.docs.commands['SetupTermRainbow'] =
      \ 'Add Rainbow-coloring to terminals'
command! -bar SetupTermRainbow
      \ autocmd TerminalOpen * RainbowLoad

let g:jm_vimrc.docs.commands['SetupAutoread'] =
      \ 'Enable autoread and add checktime autocmd'
command! -bar SetupAutoread
      \ set autoread | autocmd FocusGained,BufEnter * checktime

let g:jm_vimrc.docs.commands['SetupMatchHex'] =
      \ 'Match hex numbers'
command! -bar SetupMatchHex
      \ match GruvboxAqua /\<0x0*\zs[1-9a-f]\x*\>/

let g:jm_vimrc.docs.commands['SetupMatchNum'] =
      \ 'Match decimal numbers'
command! -bar SetupMatchNum
      \ match GruvboxAqua /\<\(0x\)\?0*\zs[1-9a-f]\x*\>/

let g:jm_vimrc.docs.commands['Dis'] =
      \ 'Setup terminal for viewing objdump output ($ objdump -d ... | vim +Dis -)'
command! -bar Dis
      \ setlocal ft=dis buftype=nofile

let g:jm_vimrc.docs.commands['ToggleFoldOpenSearch'] =
      \ 'Toggle search on foldopen option'
command! ToggleFoldOpenSearch
      \ if stridx(&foldopen, "search") == -1 |
      \   set foldopen+=search |
      \   echo "ENABLED foldopen search" |
      \ else |
      \   set foldopen-=search |
      \   echo "DISABLED foldopen search" |
      \ endif

let g:jm_vimrc.docs.commands['PyHelp'] =
      \ 'Look-up help for python expression (: PyHelp <pkg> <cls>)'
command! -nargs=+ -bang PyHelp
      \ call py3eval((<bang>0) ? printf('help(%s)', <q-args>) : printf('help(__import__("%s").%s)', <f-args>))

let g:jm_vimrc.docs.commands['MakeOrSetup'] =
      \ 'Run blaze, make, or create a Makefile with included commands (using ; as separator)'
command! -nargs=+ MakeOrSetup call s:MakeOrSetup(<q-args>)
function! s:MakeOrSetup(cmds) abort
  if filereadable('WORKSPACE')
    execute 'Term blaze build' BlazeTarget()
  elseif filereadable('Makefile')
    Term make
  else
    let l:cmds = substitute(a:cmds, '%', expand('%'), 'g')
    let l:lines = split(l:cmds, ';')->map('trim(v:val)')
    let l:cursor = bss#cursor#SaveWithBuf()
    try
      redir > Makefile
      silent echo '.PHONY: all'
      silent echo 'all:'
      for l:cmd in l:lines
        silent echo '	' .. l:cmd
      endfor
      redir END
      silent edit Makefile
      Term make
    finally
      call l:cursor.Restore()
    endtry
  endif
endfunction

" The Silver Searcher
if executable('ag')
    " Use ag over grep
    set grepprg=ag\ --nogroup\ --nocolor\ --ignore=tags
endif
" }}} Commands

" FT-Specific Settings: {{{

" Autocommands are split into filetype `augroup`s, each is separated by
" filetype. This solves the problem of sourcing the vimrc multiple times
" causing multiple duplicated autocommands to be set. An augroup is only run
" once**.
"
" These keymappings depend on the filetype, when :filetype on is enabled (as
" it is earlier in this config), when vim first loads a buffer, it will
" automatically detect the filetype and set the 'filetype' option (buffer)
" locally. After this happens, any `FileType` type autocommands are triggered
"
" NOTES:
" ** An augroup doesn't provide this functionality by itself. When you
" redefine it, it will 'add onto' the original one, in order to clear one, you
" can add `autocommand!` or `au!` to it (or another with the same name). This
" is used to make sure that only one version of the autocommand hooks is set
" per buffer.
augroup ft_latex
    autocmd!
    autocmd FileType tex setlocal nocursorline
    autocmd FileType tex setlocal tabstop=4 shiftwidth=4
    autocmd FileType tex nnoremap <buffer> <localleader>r
          \ :execute 'Term fish -c "mkt ' .. expand('%') .. '"'<cr>
augroup END

augroup ft_c
    autocmd!
    autocmd FileType c setlocal tabstop=2 shiftwidth=2
    autocmd FileType c setlocal foldmethod=syntax
    autocmd FileType c nnoremap <buffer> <localleader>r
          \ :Term make<CR>
    autocmd FileType c nnoremap <buffer> <localleader>R
          \ :MakeOrSetup gcc -Wall -O3 -o a.out %; ./a.out; rm a.out<cr>
augroup END


augroup ft_cc
    autocmd!
    autocmd FileType cpp setlocal tabstop=2 shiftwidth=2
    autocmd FileType cpp setlocal foldmethod=syntax
    autocmd FileType cpp nnoremap <buffer> <localleader>t
          \ :term <C-r>=BlazeGuessCommand()<CR>
    autocmd FileType cpp nnoremap <buffer> <localleader>r
          \ :MakeOrSetup
          \   clang++-12 -std=c++17 $(CFLAGS) -o build % $(LDFLAGS);
          \   ./build<CR>
    autocmd FileType cpp nnoremap <buffer> <space>f
          \ :FormatCode<CR>
    autocmd FileType cpp
          \ if exists('g:jm_setup_cpp_cv') |
          \   SetupCV |
          \ endif
    autocmd FileType cpp
          \ if expand('%:p') =~ '/home/jmend/pg' |
          \   silent ReplaceRTarget |
          \ endif
augroup END

augroup ft_gdb
    autocmd!
    autocmd FileType gdb nnoremap <buffer> <localleader>r
          \ :execute 'Term gdb -q -x' expand('%')<cr>
augroup END

augroup ft_python
    autocmd!
    autocmd FileType python command! RunPython
          \ execute "Term" g:jm_vimrc.deps.python expand('%')
    autocmd FileType python command! RunPythonTests
          \ execute "Term" g:jm_vimrc.deps.python "-m pytest" expand('%')
    autocmd FileType python command! RunPythonTypechecks
          \ execute "Term" g:jm_vimrc.deps.python "-m mypy --ignore-missing-imports --follow-imports=skip " expand("%")
    autocmd FileType python command! RunPythonMPL
          \ StopAllJobs | eval timer_start(0, {-> execute('RunPython')})
    autocmd FileType python nnoremap <buffer> <localleader>r
          \ :RunPython<cr>
    autocmd FileType python nnoremap <buffer> <localleader>R
          \ :RunPythonTests<cr>
    autocmd FileType python nnoremap <buffer> <localleader>t
          \ :RunPythonTypechecks<cr>
    autocmd FileType python nnoremap <buffer> <space>f
          \ :FormatCode<CR>
augroup END

augroup ft_scheme
    autocmd!
    autocmd FileType scheme setlocal colorcolumn=79
    autocmd FileType scheme let g:lisp_rainbow = v:true
    autocmd FileType scheme nnoremap <buffer> <localleader>r
          \ :w<CR> :Term mit-scheme --load % <CR>
augroup END

augroup ft_java
    autocmd!
    autocmd FileType java
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType java nnoremap <space>f :FormatCode<cr>
    autocmd FileType java vnoremap <space>f :FormatLines<cr>
    if filereadable('Makefile')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :Term make<cr>
    elseif filereadable('WORKSPACE')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :execute "Term blaze run " .. join(<SID>BlazeTargets(expand("%")), " ")<cr>
    elseif filereadable('gradlew')
      autocmd FileType java nnoremap <silent> <buffer> <localleader>r
            \ :Term ./gradlew run<cr>
    endif
    autocmd FileType java nnoremap <silent> <buffer> <localleader>R
          \ :Term ./gradlew run<cr>
    autocmd FileType java let b:surround_99 = "{@code \r}"
augroup END

augroup ft_jar
  autocmd!
  autocmd FileType jar
        \ call zip#Browse(expand("<amatch>"))
augroup END

augroup ft_class
  autocmd!
  autocmd BufReadCmd *.class
        \ call bss#java#javap#Browse(expand("<amatch>"))
augroup END



augroup ft_javascript
    autocmd!
    autocmd FileType javascript
          \ setlocal tabstop=2 softtabstop=2 tabstop=2 smarttab
    autocmd FileType javascript nnoremap <buffer> <localleader>r
          \ :execute "Term node " .. expand('%')<cr>
    autocmd FileType javascript nnoremap <buffer> <localleader>R
          \ :Term webpack<CR>
    autocmd FileType javascript nnoremap <buffer> <space>f
          \ :FormatCode<CR>
augroup END

augroup ft_markdown
    autocmd!
    autocmd FileType markdown set textwidth=72 smartindent

    autocmd FileType markdown nnoremap <buffer> ]h :<c-u>call search('\v^#+ ', 'Wz')<cr>
    autocmd FileType markdown nnoremap <buffer> [h :<c-u>call search('\v^#+ ', 'bWz')<cr>
    "autocmd FileType markdown nnoremap <buffer> <leader>r
                "\ :Term pandoc %:p -s --highlight-style kate --pdf-engine=xelatex -o gen/%:t:r.pdf<cr>

    autocmd FileType markdown command! SetupR nnoremap <buffer> <localleader>r
          \ :call execute(printf(
          \     "Term pandoc %s -s --highlight-style kate --pdf-engine=xelatex -o %s.pdf",
          \     expand('%:p'),
          \     expand('%:t:r'),
          \   ))<cr>

    autocmd FileType markdown command! JmMdQuotesAsComments match GruvboxFg3 /^\s*>.*/

    if !exists('g:bss_markdown_fix') || !g:bss_markdown_fix
      " Disable indent-based code blocks, this enables arbitrarily deep
      " indentation of lists
      autocmd FileType markdown syntax clear markdownCodeBlock
      autocmd FileType markdown syntax region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
      autocmd FileType markdown syntax region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend

      " Fix up the colors
      autocmd FileType markdown highlight link markdownH1 GruvboxRedBold
      autocmd FileType markdown highlight link markdownH2 GruvboxBlueBold
      autocmd FileType markdown highlight link markdownH3 GruvboxGreenBold
      autocmd FileType markdown highlight link markdownH4 GruvboxPurpleBold

      " Ensure bold/italics are highlighted
      autocmd FileType markdown highlight link markdownBold GruvboxFg4
      autocmd FileType markdown highlight link markdownBoldDelimiter GruvboxFg4
      autocmd FileType markdown highlight link markdownItalic GruvboxFg2
      autocmd FileType markdown highlight link markdownItalicDelimiter GruvboxFg2
    endif
augroup END

augroup ft_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker shiftwidth=2
    autocmd FileType vim nnoremap <buffer> <localleader>r
          \ :source %<cr>
    autocmd FileType vim nnoremap K :help <C-r><C-w><CR>
augroup END

augroup ft_fish
    autocmd!
    autocmd FileType fish setlocal tabstop=4 shiftwidth=4 smartindent
    autocmd FileType fish nnoremap <buffer> <space>f
          \ :0,$!fish_indent<cr>
    autocmd FileType fish setlocal omnifunc=bss#fish#Complete
augroup END

augroup ft_make
    autocmd!
    autocmd FileType make nnoremap <buffer> <localleader>r
          \ :Term make<cr>
augroup END

" Use quickfix window when using :make
augroup cfg_quickfix_fix
    autocmd QuickFixCmdPost [^l]* nested cwindow
    autocmd QuickFixCmdPost    l* nested lwindow
augroup end

" }}} FT-Specific Settings

" Misc: {{{

" :FindImport {Classname}
"   Attempt to find and a Java import statement for the {Classname}
"     1. Try the `g:jm_vimrc.java_import_cache`
"     2. Search the CWD using `ag` for an `import .*\.{ClassName};`
"     3. Finally, search `g:jm_vimrc.deps.JavaClassnameList()`
"   Alternatively, for C++ do only:
"     1. Try the `g:jm_vimrc.cc_import_cache`
" {{{
let g:jm_vimrc.docs.commands['FindImport'] =
      \ 'Given a name, find the corresponding import and add an import statment'
nnoremap <space>t :call <SID>FindImport(expand('<cword>'))<CR>
command -nargs=1 FindImport call <SID>FindImport(<q-args>)
function! s:FindImport(word) abort

  if &filetype ==# 'cpp'
    let l:res = g:jm_vimrc.cc_import_cache
          \->copy()
          \->filter({incl, names -> index(names, a:word) != -1})
          \->keys()
          \->map({k, incl -> printf("#include %s", incl)})
    if len(l:res) == 0
      echo "FindImport: `" .. a:word .. "` not found!"
    elseif len(l:res) > 1
      call maktaba#ui#selector#Create(l:res)
            \.WithMappings({'<cr>': [function("s:AddImportCpp")->get("name"), 'Close', 'Add import']})
            \.Show()
    else
      call s:AddImportCpp(l:res[0])
    endif
    return
  endif

  if &filetype !=# 'java'
    throw 'ERROR(InvalidFiletype)'
    return
  endif

  " First try the g:jm_vimrc.java_import_cache
  if (has_key(g:jm_vimrc.java_import_cache, a:word))
    call s:AddImport(printf('import %s;', get(g:jm_vimrc.java_import_cache, a:word)))
    return
  endif

  " Next find an import statement in the current directory
  let l:results = printf(
          \ '%s --nofilename --nobreak %s',
          \ g:jm_vimrc.deps.ag,
          \ shellescape(printf('import .+\b%s\b;', a:word)))
          \->systemlist()
          \->sort()
          \->uniq()

  " Finally, fallback to classname list
  if empty(l:results)
    let l:results = g:jm_vimrc.deps.JavaClassnameList()
          \->filter('v:val =~# a:word')
          \->map('"import " .. v:val .. ";"')
  endif

  if len(l:results) == 1
    call s:AddImport(l:results[0])
  elseif len(l:results) > 1
    call maktaba#ui#selector#Create(l:results)
          \.WithMappings({'<cr>': [function("s:AddImport")->get("name"), 'Close', 'Add import']})
          \.Show()
  endif
endfunction

function! s:AddImport(import) abort
    let l:result = search(a:import, 'nw')
    if l:result == 0
      let l:start = search('^import', 'nw')
      if l:start == 0
        let l:start = search('^package', 'nw')
        call append(l:start, [""])
        let l:start += 1
      endif
      call append(l:start, [a:import])
      "execute '1,1FormatLines'
      echom "Adding: " .. a:import
    else
      echom "Already Present: " .. a:import
    endif
endfunction

function! s:AddImportCpp(import) abort
    let l:result = search(a:import, 'nw')
    if l:result == 0
      let l:start = search('^#include', 'nw')
      call append(l:start, [a:import])
      "execute '1,1FormatLines'
      echom "Adding: " .. a:import
    else
      echom "Already Present: " .. a:import
    endif
endfunction
" }}}

" :Javap {qualified-classname}
"   Run `javap` against the provided classname
" {{{
let g:jm_vimrc.docs.commands['Javap'] =
      \ 'Execute Javap and show output with highlighting'
command! -nargs=? -complete=customlist,<SID>JavapComplete -bang
        \ Javap call <SID>Javap(<q-args>, "<bang>" ==# '!')
function! s:Javap(arg, search) abort
  if empty($CLASSPATH)
    SetupClasspath
  endif

  " Note: Vim Syntax highlighting doesn't like `\->substitute(...)`
  let l:cls = empty(a:arg) ? @" : a:arg
  let l:cls = substitute(l:cls, '\(;\|<.\+>\)', '', 'ga')

  if a:search
    let l:results = s:JavapComplete(l:cls, v:none, v:none)
    if len(l:results) == 1
      let l:cls = l:results[0]
    else
      call maktaba#ui#selector#Create(l:results)
            \.WithMappings({'<cr>': [function("s:JavapOpen")->get("name"), 'Close', 'Open window']})
            \.Show()
      return
    endif
  endif

  call g:jm_term
        \.Run([g:jm_vimrc.deps.javap, l:cls])
        \.Exec('set ft=java')
endfunction

function! s:JavapComplete(arg_lead, cmd_line, cursor_pos) abort
  return g:jm_vimrc.deps.JavaClassnameList()
        \->filter('v:val =~# a:arg_lead')
endfunction

function! s:JavapOpen(cls) abort
  execute 'Javap ' .. a:cls
endfunction
" }}}

" :MavenSearch {query}
" :M {query}
"   Run a maven query, and show results in a selector window
" {{{
let g:jm_vimrc.docs.commands['MavenSearch'] =
      \ 'Search maven, then either add a dependecy or download the jar'
command! -nargs=1 MavenSearch call <SID>MavenSearch(<q-args>)
command! -nargs=1 M MavenSearch <args>
function! s:MavenSearch(query) abort
  const l:query_url = printf(
        \ 'https://search.maven.org/solrsearch/select?q=%s&rows=10&wt=json',
        \ a:query)

  const l:query_cmd = join([
        \   g:jm_vimrc.deps.curl,
        \   '-s',
        \   printf('"%s"', l:query_url),
        \ ])

  let l:msg = system(l:query_cmd)
  let l:resp = json_decode(l:msg).response

  if l:resp.numFound == 0
    echom "None found!"
    return
  endif
  let l:docs = l:resp.docs
  const l:mappings = {
        \   '<cr>': [function("s:MInsert")->get("name"), 'Close', 'Insert below'],
        \   'D': [function("s:MDownload")->get("name"), 'Close', 'Insert below'],
        \ }
  call maktaba#ui#selector#Create(map(l:docs, 'v:val.id .. ":" ..  v:val.latestVersion'))
        \.WithMappings(l:mappings)
        \.Show()
endfunction

function! s:MInsert(msg) abort
  let l:spaces = getline('.')->matchstr('^\s*')
  call append(line('.'), printf("%simplementation '%s'", l:spaces, a:msg))
endfunction

function! s:MDownload(msg) abort
  let [l:package, l:name, l:version] = split(a:msg, ':')
  let l:url_package = substitute(l:package, '\.', '/', 'g')
  let l:url = printf('https://repo1.maven.org/maven2/%s/%s/%s/',
        \  l:url_package,
        \  l:name,
        \  l:version)
  let l:file = printf('%s-%s.jar', l:name, l:version)
  let l:file_url = l:url .. l:file
  echom l:url .. l:file

  const l:cmd = join([
        \   g:jm_vimrc.deps.curl,
        \   '-o',
        \   shellescape(l:file),
        \   '-s',
        \   shellescape(l:file_url),
        \ ])
  silent call system(l:cmd)
  if v:shell_error
    echom 'ERROR: Could not download! ' .. l:file_url
  endif
endfunction
" }}}

" Bazel/Blaze helper functions
"
"   s:BlazeTargets({fname})
"     Return the targets that depend on {fname} directly
"
"   BlazeTarget()
"     Returns the first target for the current file
"
"   s:TargetClasspath()
"     Returns the classpath for BlazeTarget()
"
"   s:CompleteTargets({arg_lead}, {cmd_line}, {cursor_pos})
"     A -complete=customlist compatible function that simply filters the
"     commandline against all targets
"
" {{{
function! s:BlazeTargets(fname) abort
  let l:query = printf(
        \   'same_pkg_direct_rdeps(%s)',
        \   fnamemodify(a:fname, ":p:."),
        \ )

  let l:command = printf(
        \   "%s query '%s'",
        \   g:jm_vimrc.deps.blaze,
        \   l:query,
        \ )
  return filter(systemlist(l:command), 'v:val =~# "^//"')
endfunction

function! BlazeGuessCommand(show = v:false) abort
  let l:fname = expand('%:p')

  let l:target = BlazeTarget()
  if l:target ==# "???"
    echom "Can't find blaze target!"
    return "false"
  endif

  let l:action = 'build'
  if l:fname =~# '\v(_test.cc|Test.java)$' || l:target =~# '\v(_test|Test)$'
    let l:action = 'test'
  elseif l:fname =~# '\v(main.cc|_bin.cc|Bin.java)$' || l:target =~# '\v(_bin|Bin|main|Main)$'
    let l:action = 'run'
  elseif l:fname =~# '\v(_bench.cc)$' || l:target =~# '\v(_bench)$'
    let l:action = 'run -c opt'
  endif

  let l:command = printf(
        \   "%s %s %s",
        \   g:jm_vimrc.deps.blaze,
        \   l:action,
        \   l:target,
        \ )
  if a:show
    echom 'Using:' l:command
  endif
  return l:command
endfunction

function! BlazeTarget() abort
  return get(s:BlazeTargets(expand('%:p')), 0, "???")
endfunction

function! s:TargetClasspath() abort
  let l:target = BlazeTarget()
  if l:target ==# "???"
    echom "Can't find blaze target!"
    return ""
  endif

  let l:lines = systemlist(printf('blaze print_action "%s"', l:target))
  let l:jars = filter(l:lines, {_, v -> v =~# '^\s\+\(outputjar\|classpath\): "[^"]*"'})
        \->map({_, v -> matchlist(v, '"\([^"]*\)"')[1]})
  return join(l:jars, ':')
endfunction

function! s:CompleteTargets(arg_lead, cmd_line, cursor_pos) abort
  if a:arg_lead =~ '^//.*'
    return systemlist(printf('%s query ... 2>&1', g:jm_vimrc.deps.blaze))
          \->filter('v:val =~# "' .. a:arg_lead .. '"')
  endif
endfunction
" }}}

" :Touch {path}...
"   Like `$ touch`, but also create directories if necessary
" {{{
let g:jm_vimrc.docs.commands['Touch'] =
      \ 'Create files and directories'
command! -nargs=* Touch call s:Touch([<f-args>])
function! s:Touch(paths) abort
  for l:path in a:paths
    let l:dir = fnamemodify(l:path, ':h')
    if l:dir !=# '.' && !isdirectory(l:dir)
      call system('mkdir -p ' .. shellescape(l:dir))
    endif
    if !filereadable(l:path)
      call system('touch ' .. shellescape(l:path))
    endif
  endfor
endfunction
" }}}

" :CurrentHLGroup
"   Print the highlight Group under cursor
" {{{
let g:jm_vimrc.docs.commands['CurrentHLGroup'] =
      \ 'Echo name of the highlight group under the cursor'
command! CurrentHLGroup echo s:SyntaxItem()
function! s:SyntaxItem()
  return synIDattr(synID(line("."), col("."), 1), "name")
endfunction
" }}}

" AsyncExec(fn)
"   Call fn() async
"
" AsyncExec(...)
"   Join string arguments and exec async
" {{{
function! s:Async(Fn)
  eval timer_start(0, a:Fn)
endfunction

function! s:AsyncExec(...)
  eval s:Async({-> execute(join(map(a:000, function('string'))))})
endfunction
" }}}

" ConcealK
"   Define conceal rules: eg. ConcealK lambda:λ
" {{{
let g:jm_vimrc.docs.commands['ConcealK'] =
      \ 'Define conceal rules: eg. ConcealK lambda:λ'
command! -complete=expression -nargs=1 ConcealK call <SID>ConcealK(<q-args>)
function! s:ConcealK(repl_str) abort
  let l:repl = {}
  let l:i = 0
  for [l:keyword, l:replacement] in split(a:repl_str, ' ')->map('v:val->split(":")')
    let l:i += 1
    execute 'syntax keyword'
          \ printf('ConcealK%03d', l:i) l:keyword
          \ 'conceal' printf('cchar=%s', l:replacement)
  endfor
  setlocal conceallevel=1
  setlocal concealcursor=ni
endfunction
" }}}

let g:jm_vimrc.docs.commands['ReadExecute'] =
      \ 'Execute then read the output of that vim command'
command! -nargs=* -complete=command ExecuteRead eval append(line('.'), execute(<q-args>)->split("\n"))

let g:jm_vimrc.docs.commands['Bdz'] =
      \ 'Run buildozer on current target (or :__pkg__ if none exists)'
command! -nargs=* Bdz echom
      \ system(printf("fish -c \"buildozer '%s' %s\"",
      \   join([<f-args>], ' '),
      \   BlazeTarget() != '???' ? BlazeTarget() : ':__pkg__'
      \ ))

command! -nargs=* -complete=customlist,<SID>JemFormatComplete JemFormat eval s:JemFormat[<q-args>]()
let s:JemFormat = {
      \   'help': {-> bss#PP(s:JemFormat, v:true)},
      \ }
function! s:JemFormatComplete(arglead, cmdline, curpos) abort
  return keys(s:JemFormat)->filter({k, v -> !stridx(v, a:arglead)})
endfunction

function! s:JemFormat.format() abort dict
  let command = self.find()
  if !empty(command)
    silent execute command
  endif
endfunction

function! s:JemFormat.find() abort dict
  let [_, num, col; _] = getcurpos()
  let start_pat   = '\v.*for' .. 'mat: `([^`]+)`.*'
  let end_pat     = '\v.*for' .. 'mat: END.*'
  let start_lines = matchbufline(bufnr(), start_pat, 1, num)
  let start_line  = bss#Last(start_lines)
  let end_line    = start_line
        \->bss#Get('lnum')
        \->bss#Apply({l -> matchbufline(bufnr(), end_pat, l, '$')})
        \->bss#Apply('bss#Last')
        \->bss#Or('$')
  if start_line is v:none
    return ''
  endif
  let range   = [start_line.lnum + 1, end_line.lnum - 1]->join(',')
  let command = substitute(start_line.text, start_pat, '\1', '')
  return join([range, command], ' ')
endfunction

function! s:ClassesInJars(jars) abort
  for l:jar in a:jars
    let l:classes = systemlist(printf('jar tf %s', l:jar))
          \->filter('v:val =~')
  endfor
endfunction

" }}} Misc

" Notes {{{
let s:Wtf = bss#wtf#Initialize()
call bss#wtf#AddDict(['mappings', 'm'], g:jm_vimrc.docs.mappings)
call bss#wtf#AddDict(['commands', 'c'], g:jm_vimrc.docs.commands)
" }}} Notes

" Defines the import cache used for Java import search, if an attempt to
" resolve the import for a key in this map, the value specified will be
" imported before trying any other method to find the import.
" Java Import Cache: {{{
let g:jm_vimrc.java_import_cache = #{
      \   Map                : 'java.util.Map',
      \   Set                : 'java.util.Set',
      \   Stream             : 'java.util.stream.Stream',
      \   Collectors         : 'java.util.stream.Collectors',
      \   Collector          : 'java.util.stream.Collector',
      \   List               : 'java.util.List',
      \   ArrayList          : 'java.util.ArrayList',
      \   LinkedList         : 'java.util.LinkedList',
      \   Iterator           : 'java.util.Iterator',
      \   Optional           : 'java.util.Optional',
      \   HashSet            : 'java.util.HashSet',
      \   HashMap            : 'java.util.HashMap',
      \   TreeMap            : 'java.util.TreeMap',
      \   TreeSet            : 'java.util.TreeSet',
      \   Arrays             : 'java.util.Arrays',
      \   Collection         : 'java.util.Collection',
      \   OrderedMap         : 'java.util.OrderedMap',
      \   NavigableMap       : 'java.util.NavigableMap',
      \   Consumer           : 'java.util.function.Consumer',
      \   Predicate          : 'java.util.function.Predicate',
      \   Function           : 'java.util.function.Function',
      \   Supplier           : 'java.util.function.Supplier',
      \   ImmutableList      : 'com.google.common.collect.ImmutableList',
      \   Lists              : 'com.google.common.collect.Lists',
      \   ImmutableSet       : 'com.google.common.collect.ImmutableSet',
      \   Streams            : 'com.google.common.collect.Streams',
      \   Table              : 'com.google.common.collect.Table',
      \   Tables             : 'com.google.common.collect.Tables',
      \   ImmutableTable     : 'com.google.common.collect.ImmutableTable',
      \   toImmutableList    : 'static com.google.common.collect.ImmutableList.toImmutableList',
      \   toImmutableSet     : 'static com.google.common.collect.ImmutableSet.toImmutableSet',
      \   ImmutableMap       : 'com.google.common.collect.ImmutableMap',
      \   Provider           : 'javax.inject.Provider',
      \   Inject             : 'javax.inject.Inject',
      \   Qualifier          : 'javax.inject.Qualifier',
      \   Singleton          : 'javax.inject.Singleton',
      \   Binds              : 'dagger.Binds',
      \   Module             : 'dagger.Module',
      \   Component          : 'dagger.Component',
      \   Provides           : 'dagger.Provides',
      \   Multibinds         : 'dagger.multibindings.Multibinds',
      \   IntoSet            : 'dagger.multibindings.IntoSet',
      \   IntoMap            : 'dagger.multibindings.IntoMap',
      \   IntKey             : 'dagger.multibindings.IntKey',
      \   LongKey            : 'dagger.multibindings.LongKey',
      \   StringKey          : 'dagger.multibindings.StringKey',
      \   ClassKey           : 'dagger.multibindings.ClassKey',
      \   ElementsIntoSet    : 'dagger.multibindings.ElementsIntoSet',
      \   MapKey             : 'dagger.MapKey',
      \   Path               : 'java.nio.file.Path',
      \   Files              : 'java.nio.file.Files',
      \   ClassReader        : 'org.objectweb.asm.ClassReader',
      \   ClassWriter        : 'org.objectweb.asm.ClassWriter',
      \   ClassVisitor       : 'org.objectweb.asm.ClassVisitor',
      \   Opcodes            : 'org.objectweb.asm.Opcodes',
      \   FieldVisitor       : 'org.objectweb.asm.FieldVisitor',
      \   MethodVisitor      : 'org.objectweb.asm.MethodVisitor',
      \   TypePath           : 'org.objectweb.asm.TypePath',
      \   Modifier           : 'java.lang.reflect.Modifier',
      \   Executable         : 'java.lang.reflect.Executable',
      \   Field              : 'java.lang.reflect.Field',
      \   Method             : 'java.lang.reflect.Method',
      \   Type               : 'java.lang.reflect.Type',
      \   AnnotatedElement   : 'java.lang.reflect.AnnotatedElement',
      \   Executor           : 'java.util.concurrent.Executor',
      \   Future             : 'java.util.concurrent.Future',
      \   ExecutorService    : 'java.util.concurrent.ExecutorService',
      \   Executors          : 'java.util.concurrent.Executors',
      \   TimeUnit           : 'java.util.concurrent.TimeUnit',
      \   ThreadPoolExecutor : 'java.util.concurrent.ThreadPoolExecutor',
      \   AtomicInteger      : 'java.util.concurrent.atomic.AtomicInteger',
      \   AtomicLong         : 'java.util.concurrent.atomic.AtomicLong',
      \   LongAdder          : 'java.util.concurrent.atomic.LongAdder',
      \   Stats              : 'com.google.common.math.Stats',
      \   Stopwatch          : 'com.google.common.base.Stopwatch',
      \   StatsAccumulator   : 'com.google.common.math.StatsAccumulator',
      \   ConcurrentHashMap  : 'java.util.concurrent.ConcurrentHashMap',
      \   assertThat         : 'static com.google.common.truth.Truth.assertThat',
      \   assertWithMessage  : 'static com.google.common.truth.Truth.assertWithMessage',
      \ }
" }}} Java Import Cache

" C++ Import Cache: {{{
let g:jm_vimrc.cc_import_cache = {
      \   '"absl/flags/flag.h"': ['ABSL_FLAG', 'GetFlag'],
      \   '"absl/flags/declare.h"': ['ABSL_DECLARE_FLAG'],
      \   '"absl/flags/parse.h"': ['ParseCommandLine'],
      \   '"absl/flags/usage.h"': ['ProgramUsageMessage', 'SetProgramUsageMessage'],
      \   '"absl/strings/str_join.h"': ['StrJoin'],
      \   '"absl/strings/str_cat.h"': ['StrCat'],
      \   '"absl/strings/str_replace.h"': ['StrReplaceAll'],
      \   '"absl/strings/str_split.h"': ['StrSplit'],
      \   '"absl/status/status.h"': ['Status'],
      \   '"absl/status/statusor.h"': ['StatusOr'],
      \   '<opencv2/core.hpp>': [
      \     'Mat',
      \     'Mat_',
      \     'Mat1b', 'Mat2b', 'Mat3b', 'Mat4b',
      \     'Mat1i', 'Mat2i', 'Mat3i', 'Mat4i',
      \     'Mat1f', 'Mat2f', 'Mat3f', 'Mat4f',
      \     'Mat1d', 'Mat2d', 'Mat3d', 'Mat4d',
      \     'Matx',
      \     'Matx22f', 'Matx33f', 'Matx44f',
      \     'Matx21f', 'Matx31f', 'Matx41f',
      \     'Matx22d', 'Matx33d', 'Matx44d',
      \     'Matx21d', 'Matx31d', 'Matx41d',
      \     'Vec',
      \     'Vec1b', 'Vec2b', 'Vec3b', 'Vec4b', 'Vec6b',
      \     'Vec1i', 'Vec2i', 'Vec3i', 'Vec4i', 'Vec6i',
      \     'Vec1f', 'Vec2f', 'Vec3f', 'Vec4f', 'Vec6f',
      \     'Vec1d', 'Vec2d', 'Vec3d', 'Vec4d', 'Vec6d',
      \     'Scalar_', 'Scalar',
      \     'Point_', 'Point2i', 'Point2l', 'Point2f', 'Point2d',
      \     'Point3_', 'Point3i', 'Point3l', 'Point3f', 'Point3d',
      \     'abs',
      \     'exp', 'log',
      \     'pow', 'sqrt',
      \   ],
      \   '<opencv2/imgcodecs.hpp>': ['imread', 'imwrite'],
      \   '<opencv2/imgproc.hpp>': ['circle'],
      \   '<utility>': [
      \     'forward', 'declval',
      \     'move', 'swap', 'exchange',
      \     'integer_sequence', 'make_integer_sequence',
      \     'index_sequence', 'make_index_sequence',
      \     'pair', 'make_pair',
      \   ],
      \   '<memory>': ['unique_ptr', 'make_unique'],
      \   '<vector>': ['vector'],
      \   '<tuple>': [
      \     'tuple',
      \     'tuple_size',
      \     'tuple_element',
      \     'get',
      \   ],
      \   '<type_traits>': [
      \     'enable_if', 'conditional',
      \     'enable_if_t', 'conditional_t',
      \     'integral_constant', 'bool_constant',
      \     'true_type', 'false_type',
      \     'conjunction', 'disjunction', 'negation',
      \     'conjunction_v', 'disjunction_v', 'negation_v',
      \     'is_same', 'is_base_of', 'is_convertible',
      \     'is_same_v', 'is_base_of_v', 'is_convertible_v',
      \   ],
      \   '<array>': ['array'],
      \   '<valarray>': ['valarray'],
      \   '<cstddef>': [
      \     'size_t', 'ptrdiff_t', 'nullptr_t',
      \   ],
      \   '<future>': [
      \     'future', 'promise', 'async', 'launch',
      \   ],
      \   '<thread>': [
      \     'thread', 'this_thread', 'yield', 'get_id', 'sleep_for',
      \   ],
      \   '<cstdint>': [
      \     'int8_t', 'int16_t', 'int32_t', 'int64_t',
      \     'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
      \   ],
      \   '<cmath>': [
      \     'abs',
      \     'exp', 'log', 'log2', 'log10',
      \     'pow', 'sqrt', 'hypot',
      \     'sin', 'cos', 'tan',
      \     'asin', 'acos', 'atan',
      \     'sinh', 'cosh', 'tanh',
      \     'asinh', 'acosh', 'atanh',
      \     'ceil', 'floor', 'trunc', 'round',
      \   ],
      \   '<string>': [
      \     'string',
      \     'to_string',
      \     'stoi', 'stol', 'stoul', 'stoll', 'stoull',
      \     'stof', 'stod', 'stold',
      \   ],
      \   '<map>': ['map'],
      \   '<unordered_map>': ['unordered_map'],
      \   '<set>': ['set'],
      \   '<iostream>': [
      \     'cout', 'cin', 'cerr',
      \     'endl',
      \   ],
      \   '<ios>': [
      \     'internal', 'left', 'right',
      \     'boolalpha', 'showbase', 'showpos',
      \     'dec', 'hex', 'oct',
      \     'fixed', 'scientific', 'default',
      \   ],
      \   '<format>': ['format'],
      \   '<iomanip>': [
      \     'setw',
      \     'quoted',
      \   ],
      \   '<unordered_set>': ['unordered_set'],
      \   '<optional>': ['optional'],
      \   '<complex>': ['complex'],
      \   '<initializer_list>': ['initializer_list'],
      \   '<numeric>': [
      \     'iota',
      \     'accumulate',
      \     'reduce',
      \     'inner_product',
      \     'adjacent_difference',
      \     'partial_sum',
      \   ],
      \   '<cstdlib>': [
      \     'system',
      \     'exit',
      \     'getenv',
      \     'malloc',
      \     'free',
      \     'aligned_malloc',
      \   ],
      \   '<random>': [
      \     'random_device',
      \     'mt19937',
      \     'mt19937_64',
      \     'uniform_real_distribution',
      \     'uniform_int_distribution',
      \     'normal_distribution',
      \   ],
      \   '<functional>': [
      \     'function',
      \     'plus', 'minus', 'multiplies', 'divides',
      \     'equal_to', 'not_equal_to',
      \     'greater', 'less', 'greater_equal', 'less_equal',
      \     'logical_and', 'logical_or', 'logical_not',
      \     'bit_end', 'bit_or', 'bit_xor', 'bit_not',
      \   ],
      \   '<algorithm>': [
      \
      \     'all_of', 'any_of', 'none_of',
      \     'for_each', 'for_each_n',
      \     'count', 'count_if',
      \     'mismatch',
      \     'find', 'find_if', 'find_if_not',
      \     'find_end', 'find_first_of', 'adjacent_find',
      \     'search', 'search_n',
      \
      \     'copy', 'copy_backward', 'move', 'move_backward', 'copy_n',
      \     'fill', 'fill_n', 'transform', 'generate', 'generate_n',
      \     'remove', 'remove_if', 'remove_copy', 'remove_copy_if',
      \     'replace', 'replace_if', 'replace_copy', 'replace_copy_if',
      \     'swap', 'swap_ranges', 'swap_iter',
      \     'reverse', 'reverse_copy', 'rotate',
      \     'rotate_copy',
      \     'shuffle',
      \     'max', 'min', 'max_element', 'min_element', 'minmax',
      \   ],
      \   '"absl/algorithm/container.h"': [
      \
      \     'c_all_of', 'c_any_of', 'c_none_of',
      \     'c_for_each', 'c_for_each_n',
      \     'c_count', 'c_count_if',
      \     'c_mismatch',
      \     'c_find', 'c_find_if', 'c_find_if_not',
      \     'c_find_end', 'c_find_first_of', 'c_adjacent_find',
      \     'c_search', 'c_search_n',
      \
      \     'c_copy', 'c_copy_backward', 'c_move', 'c_move_backward', 'c_copy_n',
      \     'c_fill', 'c_fill_n', 'c_transform', 'c_generate', 'c_generate_n',
      \     'c_remove', 'c_remove_if', 'c_remove_copy', 'c_remove_copy_if',
      \     'c_replace', 'c_replace_if', 'c_replace_copy', 'c_replace_copy_if',
      \     'c_swap', 'c_swap_ranges', 'c_swap_iter',
      \     'c_reverse', 'c_reverse_copy', 'c_rotate',
      \     'c_rotate_copy',
      \     'c_shuffle',
      \   ],
      \   '<iterator>': [
      \     'istream_iterator',
      \     'ostream_iterator',
      \   ],
      \ }
" }}} C++ Import Cache
