priority -1

# In general
#  Blocks     don't add ';'
#  Statements do    add ';'
#
# <mods> ::= P (public)
#          | # (protected)
#          | p (private)
#          | a (abstract)
#          | d (default)
#          | s (static)
#          | f (final)
#          | S (synchronized)
#
# classes, fields, methods:
#  cl<mods> f<mods> m<mods> in<mods> ct<mods>
#
# Java core:
#  re ~ return
#  if ~ if statement
#
# Java doc:
#  ** *p *r
#
# Types:
#  S L M LF
#
# Lambda: ->
#
# Misc:
#  Tt T=
#  sw
#  ext: if elif for fore fori
#
# Exceptions:
#  try tryr ca fi
#  th thr thi thu thin
#

global !p

def type_to_name(snip, text):
	snip.rv = _type_to_name(text)

def _type_to_name(text):
	if len(text) == 0:
		return ''
	elif '<' in text:
		return _type_to_name(text[:text.find('<')])
	else:
		return text[0].lower() + text[1:]

def lambda_prefix_to_args(text):
	args = (text or '').split(',')
	return f'({", ".join(args)})'


# Supports: [P#padsfS]+
#  See {mapping} for details
def modifiers(snip, mods, default=''):
	mapping = {
		'P': 'public',
		'#': 'protected',
		'p': 'private',
		'a': 'abstract',
		'd': 'default',
		's': 'static',
		'f': 'final',
		'S': 'synchronized',
	}
	after = ' ' if (mods or default) else ''
	mod_strings = [v for k, v in mapping.items() if k in (mods or default)]
	snip.rv = ' '.join(mod_strings) + after

endglobal

# Packages

snippet d.
dagger.
endsnippet

snippet d.m
dagger.multibindings.
endsnippet

snippet d.p
dagger.producers.
endsnippet

snippet d.p.m
dagger.producers.monitoring.
endsnippet

snippet j.u
java.util.
endsnippet

snippet j.i
java.io.
endsnippet

snippet j.cn
java.util.concurrent.
endsnippet

snippet j.s
java.util.stream.
endsnippet

snippet g.b
com.google.common.base.
endsnippet

snippet g.c
com.google.common.collect.
endsnippet

snippet g.cn
com.google.common.util.concurrent.
endsnippet

# Core Language

snippet pa
package `!v substitute(split(expand('%:p:h'), '/java/')[-1], '/', '.', 'g')`;
endsnippet

snippet im
import `!v substitute(split(expand('%:p:h'), '/java/')[-1], '/', '.', 'g')`$1;
endsnippet

snippet pp
System.out.format("${1:%s}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}${2:${VISUAL}}${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet po
System.out.println(
	MoreObjects.toStringHelper(${1:"name"}) //
		.add(${2:"x", 0}));
endsnippet

snippet re "return"
return ${2:${1:${VISUAL:null/;//}};}
endsnippet

snippet if "if statement"
if ($1) {
	${2:${VISUAL:System.out.println("TODO");}}
}
endsnippet

snippet ifc "if condition"
if (${2:${VISUAL:/;//}}) {
	$1
}
endsnippet

snippet for "for statement"
for (var ${1:elem} : ${2:List.of()}) {
	${VISUAL}$0
}
endsnippet

snippet fori "for statement"
for (var ${1:i} = 0; $1 < ${2:10}; $1++) {
	${VISUAL}$0
}
endsnippet

snippet v "var field"
var ${1:name} = ${3:${2:${VISUAL:null/;//}};}$0
endsnippet

snippet /\bf([P#psf]*)/ "field" r
`!p modifiers(snip, match.group(1), 'pf')`${1:String} ${2:`!p type_to_name(snip, t[1])`}${VISUAL/(.+);?/ = $1/};$0
endsnippet

snippet /\bf([P#psf]*)=/ "field with value" r
`!p modifiers(snip, match.group(1), 'pf')`${1:String} ${2:`!p type_to_name(snip, t[1])`} = ${3:${VISUAL:null/;//}};$0
endsnippet

snippet /\bm([P#padsfS]*)/ "method" r
`!p modifiers(snip, match.group(1), 'p')`${1:String} ${2:`!p type_to_name(snip, t[1])`}($3) {
	${4:${VISUAL}}
}$0
endsnippet

snippet /\bcl([P#padsfS]*)/ "Class" r
`!p modifiers(snip, match.group(1), 'P')`class ${1:`!v expand('%:t:r')`} {
	${2:${VISUAL}}
}$0
endsnippet

snippet /\bin([P#padsfS]*)/ "interface" r
`!p modifiers(snip, match.group(1), 'P')`interface ${1:Name} {
	${2:${VISUAL}}
}$0
endsnippet

snippet sw "switch"
switch ($1) {
	case $2:
		${3:${VISUAL}}
}$0
endsnippet

snippet cs "case"
case $1:
	$0
endsnippet

snippet br "break"
break
endsnippet


snippet /([a-zA-Z,]*)->/ "Lambda" r
${2:`!p snip.rv = lambda_prefix_to_args(match.group(1))`} -> ${1:${VISUAL:\{\}/(.*\n.*)/{\n$1\n}/}}
endsnippet

snippet /([a-zA-Z,]*)->>/ "Multiline-lambda" r
${2:`!p snip.rv = lambda_prefix_to_args(match.group(1))`} -> {
	${1:${VISUAL:return null/;$//}};
}$0
endsnippet

snippet ** "javadoc"
/**
 * ${1:"This method..."}.$0
 */
endsnippet

snippet *p
@param ${1:name} ${2:<usage>}
endsnippet

snippet *r
@return ${1:<description>}
endsnippet

# Exceptions

snippet try
try {
	${1:${VISUAL}}
} catch(${2:Exception} e) {
	${3:throw new RuntimeException(e)};
}
endsnippet

snippet tryi "forward interrupt and throw"
try {
	${1:${VISUAL}}
} catch(InterruptedException e) {
	Thread.currentThread().interrupt();
	throw new RuntimeException(e);
}
endsnippet

snippet tryi "return"
try {
	${1:${VISUAL}}
} catch(InterruptedException e) {
	return;
}
endsnippet

snippet ca
catch(${1:Exception} e) {
	${2:${VISUAL:throw new RuntimeException(e)}};
}
endsnippet

snippet fi
finally {
	${1:${VISUAL}}
}
endsnippet

snippet tryr
try (${1:${VISUAL/([^;\n]*);(\n(.*))?/$1/}}) {
	${2:${VISUAL/([^;\n]*);(\n(.*))?/$2/}}
}
endsnippet

snippet th
throw ${1:e};
endsnippet

snippet thr
throw new RuntimeException($1);
endsnippet

snippet thi
throw new IllegalStateException($1);
endsnippet

snippet /thu/ "" r
throw new UnsupportedOperationException($1);
endsnippet

snippet thin
if (Thread.interrupted()) {
	throw new InterruptedException();
}
endsnippet

snippet intr
if (Thread.interrupted()) {
	throw new InterruptedException();
}
endsnippet

# Type support

snippet Tt "Type, and name" i
${1:T} ${2:`!p type_to_name(snip, t[1])`}$0
endsnippet

snippet tt "Type, and name" i
${1:T} ${2:`!p type_to_name(snip, t[1])`}$0
endsnippet

snippet T= "Type, name, and value" i
${1:T} ${2:`!p type_to_name(snip, t[1])`} = ${3:new `!p type_to_name(snip, t[1])`($4)};
endsnippet

snippet t= "Type, name, and value" i
${1:T} ${2:`!p type_to_name(snip, t[1])`} = ${3:new `!p type_to_name(snip, t[1])`($4)};
endsnippet

snippet tpt "Type, and provider for t" i
${1:T} provide${1/<.*//}($1 ${1/(.*)(<.*)/\l$1/})
endsnippet

# Misc Snippets

snippet time
{
	Stopwatch sw = Stopwatch.createStarted();
	${1:${VISUAL:int x = 10/;//};}
	System.out.format("Elapsed: %s\n", sw.elapsed());
}
endsnippet

snippet test
@Test
public void ${3:${1:actionTaken}_${2:expectedResult}}() {
	assertThat(null).isNull();
}
endsnippet

snippet sub "Flow.Subscriber" i
new Flow.Subscriber<${1:T}>() {
	@Override
	public void onSubscribe(Flow.Subscription subscription) {}

	@Override
	public void onNext($1 value) {}

	@Override
	public void onError(Throwable error) {}

	@Override
	public void onComplete() {}
}
endsnippet

snippet ibench
import java.util.concurrent.TimeUnit;
import org.openjdk.jmh.annotations.AuxCounters;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.CompilerControl;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Group;
import org.openjdk.jmh.annotations.GroupThreads;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OperationsPerInvocation;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.TearDown;
import org.openjdk.jmh.annotations.Threads;
import org.openjdk.jmh.annotations.Timeout;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.BenchmarkParams;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.infra.Control;
import org.openjdk.jmh.infra.IterationParams;
import org.openjdk.jmh.infra.ThreadParams;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.CommandLineOptionException;
import org.openjdk.jmh.runner.options.CommandLineOptions;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
endsnippet

snippet cbench
@BenchmarkMode(Mode.AverageTime)
@Fork(2)
@Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
public class ${1:`!v expand('%:t:r')`} {
	$0
}
endsnippet

snippet sbench
@Setup(Level.Iteration)
public void setup() {
	$0
}
endsnippet

snippet bench
@Benchmark
public Object ${1:benchmark}() {
	return null;
}
endsnippet

snippet benchm "Provided main"
org.openjdk.jmh.Main.main(new String[]{$1});$0
endsnippet

snippet benchm "Call Runner"
new Runner(
		new OptionsBuilder() //
		.include(".*")
		.forks(1)
		.build())
.run();
endsnippet

snippet benchmain "Provided main"
org.openjdk.jmh.Main.main(new String[]{$1});$0
endsnippet

snippet benchmain "Call Runner"
new Runner(
		new OptionsBuilder() //
		.include(".*")
		.forks(1)
		.build())
.run();
endsnippet

snippet benchr "Runner"
new Runner(
		new OptionsBuilder() //
		.include(".*")
		.result("/tmp/last_benchmark.csv")
		.resultFormat(ResultFormatType.CSV)
		.forks(1)
		.build())
.run();
endsnippet

snippet ths
throws ${1:Exception}
endsnippet

snippet Phased
static class Phased implements Executor {
	private Phaser p = new Phaser(1);
	private Phaser d = new Phaser(1);
	private ExecutorService exec;

	public Phased() {
		this(Executors.newCachedThreadPool());
	}

	public Phased(ExecutorService exec) {
		this.exec = exec;
	}

	@Override
	public void execute(Runnable runnable) {
		p.register();
		d.register();
		exec.execute(() -> taskFor(runnable));
	}

	public void runAndAwait() {
		p.arrive();
		d.arriveAndAwaitAdvance();
	}

	public void shutdown() {
		p.forceTermination();
		d.forceTermination();
		exec.shutdownNow();
	}

	private void taskFor(Runnable runnable) {
		int phase    = p.arriveAndDeregister();
		int newPhase = p.awaitAdvance(phase);
		if (newPhase < 0) return; // Terminated.
		runnable.run();
		d.arriveAndDeregister();
	}
}
endsnippet

snippet await "CyclicBarrier.await"
try {
	${1:barrier}.await();
} catch (InterruptedException e) {
	throw new RuntimeException(e);
} catch (BrokenBarrierException e) {
	throw new RuntimeException(e);
}
endsnippet

snippet await "Phaser.awaitAdvance(phase)"
${1:phaser}.awaitAdvance(${2:phase});
endsnippet

snippet await "Phaser.arriveAndAwaitAdvance()"
${1:phaser}.arriveAndAwaitAdvance();
endsnippet

snippet get "Future.get"
try {
	$2${1:future}.get();
} catch (InterruptedException e) {
	throw new RuntimeException(e);
} catch (ExecutionException e) {
	throw new RuntimeException(e);
}
endsnippet

snippet stream "map a list"
${1:list}.stream()
	.map(${2:Function.identity()})
	.collect(${3:Collectors.toList()});
endsnippet

snippet range
IntStream.range(0, ${1:10}).forEach(u -> {
	${2:System.out.println(u);}
});
endsnippet

snippet var
var ${1:x} = ${2:${VISUAL:null/;$//}};
endsnippet

snippet varp
var ${1:x} = ${2:${VISUAL:null/;$//}};
System.out.println($1);
endsnippet

snippet aint
AtomicInteger ${1:x} = new AtomicInteger(${2:0});
endsnippet

snippet along
AtomicLong ${1:x} = new AtomicLong(${2:0L});
endsnippet

snippet afloat
AtomicFloat ${1:x} = new AtomicFloat(${2:0.0f});
endsnippet

snippet adouble
AtomicDouble ${1:x} = new AtomicDouble(${2:0.0});
endsnippet

snippet aref
AtomicReference<${2:T}> ${1:x} = new AtomicReference<>();
endsnippet

snippet provides
@Provides
static ${1:Integer} provide${1/<.*//}(${2:${1/<.*//}}) {
	return ${3:1000};
}
endsnippet

snippet binds
@Binds
${1:T} provide${1/<.*//}(${1/<.*//}Impl impl)
endsnippet

snippet produces
@Produces
static ${1:Integer} produce${1/<.*//}($2) {
	return ${3:1000};
}
endsnippet

snippet mod
@Module
public interface ${1:ExampleModule} {
	$2
}
endsnippet

snippet comp
@Component(modules = {})
interface ${1:C} {
	$1 get();

	public static $1 create() {
		// return DaggerSurrounding_$1.create();
		return Dagger$1.create();
	}
}
endsnippet

snippet pcomp
@ProductionComponent(modules = {ExecutorModule.class})
interface ${1:C} {
	$1 get();

	public static $1 create() {
		// return DaggerSurrounding_$1.create();
		return Dagger$1.create();
	}
}
endsnippet

snippet ExecutorModule
@Module
public static class ExecutorModule {
	private final ExecutorService executor;

	@Provides
	@Singleton
	ExecutorService provideExecutorService() {
		return Executors.newSingleThreadExecutor();
	}

	@Provides
	@Production
	Executor provideExecutor() {
		return executor;
	}
}
endsnippet
